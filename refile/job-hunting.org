#+STARTUP: content

* Job Hunting
** Job Information
*** Huawei：云核心网：AI平台/性能优化
**** 笔试
1. 题目描述
Sam从小就对元音字母(a,e,i,o,u,A,E,,O,U)很感兴趣，他在写日记的时候都会
把元音字母写成大写的，辅音字母则都写成小写，为了避免妈妈偷看自己的日
记，他同时会把元音字母复写一遍;我们摘录一段Sam日 记的字符串S(长度不超
过100，只包含大小写的英文字母和空格)，请把它还原为可以正常阅读的字符
串(单词的首字母大写)。
你试试把Sam日记的一个句子翻译成正常句子吧。
输入描述:
输入一个字符串s (长度不超过100，只包含大小写的英文字母和空格)。
输出描述:
根据Sam写日记的习惯输出翻译后正常的字符串S。
示例1输入输出示例仅供调试，后台判题数据一般不包含示例
输入      | 复制
wh00 100vEE sAAm
输出      | 复制
Who Love Sam

2. 题目描述
有一个英文字符串str，其中包含多个单词，单词之间用单个空格分隔，一行最
多显示的字符数通过maxLine表示，其中maxLine > 2个字节;
1)如果该单词正好可以显示在该行，那么不需要连字符;
2)如果该单词无法在本行完整显示，那么需要连字符"一"分割，其中连字符放在
行尾，该单词的其他部分移到下一行; maxLine比较小的情况，该单词可能显
示在多行，需要多个连字符;
3)如果该行尾正好是空格，那么不需要连字符;空格后的单词直接移到下一
行;
4)如果行尾正好是某个单词的第一个字符， 那么这个单词直接移到下一行显
示; (本行会少一个字符， 不需要添加额外的空格)
输入描述:
第一行为英文字符串;字符串包含结尾NULL最长1000字节;
第二行为行的最大宽度;
输出描述:
分割后的多行字符串，每行字符串包含在{}中;

3. 题目描述
集合的运算
**** 问题
1. MEC(mobile edge calculation)移动边缘计算，是和部门相关的业务吗？未来的发展方向是什么？
2. 5G和物联网对现有的网络结构会产生较大影响吗？现有架构可以满足相关需求吗？
3. 会考虑替代CPU的硬件吗？
*** ByteDance: 硬件开发工程师
**** 提问
1. 硬件开发工程师的主要任务是什么？你们主要在解决什么问题？
2. 我理解的字节跳动是互联网大厂，有发展硬件的需求吗？如果需求完成，硬件开发是否就是要淘汰掉？
3. 硬件开发对软件、语言、和算法的要求是什么？需要补相关的知识吗？
4. AILab的发展方向是什么？
** Resume
https://github.com/chxin/resume
** TODO Leetcode [[/Users/xin/Documents/Leetcode/makefile][workspace]]
*** NEXT leetcode daily
    :PROPERTIES:
    :STYLE: habit
    :REPEAT_TO_STATE: NEXT
    :LAST_REPEAT: [2020-07-02 Thu 10:08]
    :END:
    :PROPERTIES:
    :LAST_REPEAT: [2020-06-06 Sat 13:45]
    :ID:       5FB13F87-D183-41D8-A027-006D6073F9B0
    :END:
    - State "DONE"       from "NEXT"       [2020-06-06 Sat 13:45]
    - State "DONE"       from "NEXT"       [2020-06-05 Fri 13:37]
    - State "DONE"       from "NEXT"       [2020-06-04 Thu 14:52]
    - State "DONE"       from "NEXT"       [2020-05-31 Sun 19:12]
    - State "DONE"       from "NEXT"       [2020-05-30 Sat 13:32]
    - State "DONE"       from "NEXT"       [2020-05-29 Fri 13:56]
    - State "DONE"       from "NEXT"       [2020-05-27 Wed 21:43]
    - State "DONE"       from "NEXT"       [2020-05-25 Mon 21:23]
    - State "DONE"       from "NEXT"       [2020-05-23 Sat 16:55]
    - State "DONE"       from "NEXT"       [2020-05-09 Sat 15:07]
    - State "DONE"       from "NEXT"       [2020-05-08 Fri 13:25]
    - State "DONE"       from "NEXT"       [2020-05-06 Wed 13:58]
    - State "DONE"       from "NEXT"       [2020-05-05 Tue 13:25]
    - State "DONE"       from "NEXT"       [2020-05-04 Mon 17:31]
    - State "DONE"       from "NEXT"       [2020-04-16 Thu 13:51]
    - State "DONE"       from "NEXT"       [2020-04-15 Wed 14:21]
    - State "DONE"       from "NEXT"       [2020-04-14 Tue 11:14]
    - State "DONE"       from "NEXT"       [2020-04-10 Fri 15:15]
    - State "DONE"       from "NEXT"       [2020-04-06 Mon 13:20]
    - State "DONE"       from "NEXT"       [2020-04-05 Sun 14:27]
    - State "DONE"       from "NEXT"       [2020-04-04 Sat 14:22]
    - State "DONE"       from "NEXT"       [2020-04-03 Fri 13:37]
    - State "DONE"       from "NEXT"       [2020-04-01 Wed 15:10]
    - State "DONE"       from "NEXT"       [2020-03-30 Mon 14:01]
    - State "DONE"       from "NEXT"       [2020-03-29 Sun 14:15]
    - State "DONE"       from "NEXT"       [2020-03-28 Sat 17:28]
    - State "DONE"       from "NEXT"       [2020-03-27 Fri 16:34]
    - State "DONE"       from "NEXT"       [2020-03-24 Tue 13:11]
    - State "DONE"       from "NEXT"       [2020-03-23 Mon 20:31]
    - State "done"       from ""           [2020-03-05 Thu 17:00]
    [2020-03-05 Thu 11:19]

    SCHEDULED: <2020-07-03 Fri 13:30 .+1d/2d>
    :PROPERTIES:
    :STYLE: habit
    :REPEAT_TO_STATE: NEXT
    :END:

**** DONE 30.串联所有单词的子串
     CLOSED: [2020-03-13 Fri 18:37]

     [[~/Documents/Leetcode/30.串联所有单词的子串.cpp][solution]]

      :LOGBOOK:
      CLOCK: [2020-03-05 Thu 16:08]--[2020-03-05 Thu 16:59] =>  0:51
      CLOCK: [2020-03-05 Thu 13:41]--[2020-03-05 Thu 14:24] =>  0:43
      :END:

**** DONE 20:有效括号
     CLOSED: [2020-03-13 Fri 18:37]
    :LOGBOOK:
    CLOCK: [2020-03-01 Sun 14:35]--[2020-03-01 Sun 15:15] =>  0:40
    :END:

***** 自己方法未解决
***** 参考[[https://www.cnblogs.com/ariel-dreamland/p/9128258.html][使用堆栈]]的方法AC了
**** DONE 125:验证回文串
     CLOSED: [2020-03-26 Thu 17:31]
     :LOGBOOK:
     CLOCK: [2020-03-26 Thu 16:21]--[2020-03-26 Thu 16:59] =>  0:38
     :END:

*** DONE leetcode solution
    CLOSED: [2020-07-02 Thu 18:50]
从 Leetcode 中精选大概 200左右的题目，去除了某些繁杂但是没有多少算法思想的题目，同时保留了面试中经常被问到的经典题目。

**** 数据结构相关
   1. [[file:~/Documents/Leetcode/note/Leetcode-%E9%93%BE%E8%A1%A8.org][链表]]
   2. [[file:~/Documents/Leetcode/note/Leetcode-%E6%A0%91.org][树]]
   3. [[file:~/Documents/Leetcode/note/Leetcode-栈和队列.org][栈和队列]]
   4. [[file:~/Documents/Leetcode/note/Leetcode-哈希表.org][哈希表]]
   5. [[file:~/Documents/Leetcode/note/Leetcode-字符串.org][字符串]]
   6. [[file:~/Documents/Leetcode/note/Leetcode-数组与矩阵.org][数组与矩阵]]
   7. [[file:~/Documents/Leetcode/note/Leetcode-图.org][图]]
   8. [[file:~/Documents/Leetcode/note/Leetcode-位运算.org][位运算]]

**** 算法思想
   1. [[file:~/Documents/Leetcode/note/Leetcode-双指针.org][双指针]]
   2. [[file:~/Documents/Leetcode/note/Leetcode-排序.org][排序]]
   3. [[file:~/Documents/Leetcode/note/Leetcode-贪心思想.org][贪心思想]]
   4. [[file:~/Documents/Leetcode/note/Leetcode-二分查找.org][二分查找]]
   5. [[file:~/Documents/Leetcode/note/Leetcode-分治.org][分治]]
   6. [[file:~/Documents/Leetcode/note/Leetcode-搜索.org][搜索]]
   7. [[file:~/Documents/Leetcode/note/Leetcode-动态规划.org][动态规划]]
   8. [[file:~/Documents/Leetcode/note/Leetcode-数学.org][数学]]

**** 参考资料
   1. Leetcode
   2. Weiss M A, 冯舜玺. 数据结构与算法分析------C 语言描述[J]. 2004.
   3. Sedgewick R. Algorithms[M]. Pearson Education India, 1988.
   4. 何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014.
   5. 《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008.
   6. 左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.
** Reading Milestone
*** software basic knowledge [0/4]
   - [ ] C++ primer
   - [ ] algorithm introduction
   - [ ] network
   - [ ] embedded linux

*** hardware basic knowledge [0/1]
   - [ ] FPGA
   - [ ] Digital Circuit

** Interview Skills
*** 牛客网处理输入输出
https://blog.csdn.net/qq_29996285/article/details/84937561

*** 分析问题的步骤
1. 寻找复杂问题的子问题
2. 寻找子问题的规律： 先从最简单的情况分析，下一步如果能利用上一步的结果（递归），下一步比上一步更复杂且无关系，就需要总结规律（循环）

*** 和面试官讲解自己的步骤
1. 在问清楚了问题是什么之后，再讲解思路
2. 逐步递进：可以使用xxx吗，在这道题使用xxx对应了步骤xxx
3. 确认边界条件
4. 优化：根据时间复杂度和空间复杂度的限制，写下算法步骤，并通过举例或图解释

*** 写代码时需要避免的问题
1. 不要忘输出的要求
2. 选择合理的数据结构（数据导入，数据取值）
3. 分析问题时要彻底
4. 卡壳的思路和正确有效的思路只差一点点，要小心求证，大胆尝试

** Knowledge
*** DONE FPGA interviews
    CLOSED: [2020-07-02 Thu 18:50]

  1. https://blog.nowcoder.net/n/0a68e0a09141471a98bf2a2cec51af3a
  2. https://mp.weixin.qq.com/s/-Lu4HFVGpZA6edlGodtD8A

**** compnay
***** ASIC工程师面试经验分享

     * 商汤（一共4面，全程微信语音）- FPGA自动驾驶优化验证
     * 百度（一共3面，全程微信）- 芯片验证
     * 寒武纪（一共3面）- 芯片验证
     * 华为海思（一共3面）- 芯片
     * 在面经下的问答

***** 数字芯片设计工程师面试经验（实习加校招）

     * 腾讯实习（量子实验室）
     * 华为实习
     * 华为海思秋招面经
     * 寒武纪
     * vivo

***** 2020校招芯片设计工程师面经

     * 寒武纪（芯片设计）一面挂
     * akuna capital（FPGA开发）二面挂
     * 百度（芯片验证）三面挂
     * 华为（海思数字芯片）拿了offer
     * 英伟达（FPGA/Emu）拿了offer
     * OPPO（芯片设计）拿了offer

***** 2019数字IC求职笔记（涵盖十余家国内一流IC公司）

     * 华为
     * 兆芯
     * 全志科技
     * 寒武纪
     * 格科微电子
     * 比特大陆
     * Cadence&AMD
     * 大疆

**** questions
***** 什么是同步逻辑和异步逻辑？（汉王）

  同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。答案应该与上面问题一致

  〔补充〕：同步时序逻辑电路的特点：各触发器的时钟端全部连接在一起，并接在系统时钟端，只有当时钟脉冲到来时，电路的状态才能改变。改变后的状态将一直保持
  到下一个时钟脉冲的到来，此时无论外部输入 x 有无变化，状态表中的每个状态都是稳定的。

  异步时序逻辑电路的特点：电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外
  部输入的变化直接引起。

***** 同步电路和异步电路的区别

  同步电路：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。

  异步电路：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，这有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同
  步。

***** 时序设计的实质

  电路设计的难点在时序设计，时序设计的实质就是满足每一个触发器的建立/保持时间的而要求。

***** 建立时间与保持时间的概念？

  建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的时间。

  保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的时间。

  不考虑时钟的skew，D2的建立时间不能大于（时钟周期T - D1数据最迟到达时间T1max+T2max）；保持时间不能大于（D1数据最快到达时间T1min+T2min）；否则
  D2的数据将进入亚稳态并向后级电路传播

***** 为什么触发器要满足建立时间和保持时间？

  因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时 需
  要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入 信号对
  于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。

  （比较容易理解的方式）换个方式理解：需要建立时间是因为触发器的D段像一个锁存器在接受数据，为了稳定的设置前级门的状态需要一段稳定时间；需要保持时间是
  因为在时钟沿到来之后，触发器要通过反馈来所存状态，从后级门传到前级门需要时间。

***** 什么是亚稳态？为什么两级触发器可以防止亚稳态传播？

  这也是一个异步电路同步化的问题。

  亚稳态是指触发器无法在某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一步同位器”，他只能用来对一位异步 信号
  进行同步。两级触发器可防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下 一个脉冲
  沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到 来时，第二级
  触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 < = 时钟周
  期。

  更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。所以，这样的同步电路对于从较慢的时
  钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没有作用 。

***** 系统最高速度计算（最快时钟频率）和流水线设计思想：

  同步电路的速度是指同步系统时钟的速度，同步时钟愈快，电路处理数据的时间间隔越短，电路在单位时间内处理的数据量就愈大。

  假设Tco是触发器的输入数据 被时钟 打入到触发器到数据到达触发器输出端的延时时间；Tdelay是组合逻辑的延时；Tsetup是Ｄ触发器的建立时间。假设数据已被时钟打入D触发 器，那么数据到达第一个触 发器的Ｑ输出端需要的延时时间是Tco，经过组合逻辑的延时时间为Tdelay，然后到达第二个触发器的Ｄ端，要希望时钟能在第 二个触发器再次被稳定地打入触发器，
  则时钟的延迟必须大于Tco＋Tdelay＋Tsetup，也就是说最小的时钟周期Tmin =Tco＋Tdelay＋Tsetup，即最快的时钟频率Fmax =1/Tmin。
  FPGA开发软件也是通过这种方法来计算系统最高运行速度Fmax。因为Tco和Tsetup是由具体的器件工艺决定的，故设计电路时只 能改变组合逻辑的延迟时间Tdelay，所以说缩短触发器间组合逻辑的延时时间是提高同步电路速度的关键所在。

  由于一般同步电路都大于一级锁存，而要使电 路稳定工作，时钟周期必须满足最大延时要求。故只有缩短最长延时路径，才能 提高电路的工作频率。可以将较大的组合逻辑分解为较小的N块，通过适当的方法平 均分配组合逻辑，然后在中间插入触发器，并和原触发器使用相同的时钟，就可以避 免在两个触发器之间出现过大的延时，消除速度瓶颈，这样可以提高电路的工作 频率。这就是所谓"流水线"技术的基本设计思想，即原设计速度受限部分用一个时钟周期 实现，采用流水线技术插入触发器后，可用N个时钟周期实现，因此系统 的工作速度可以加快，吞吐量加大。注意，流水线设计会在原数据通路上加入延时，另外硬件面 积也会稍有增加。

***** 时序约束的概念和基本策略？

  时序约束主要包括周期约束，偏移约束，静态时序路径约束三种。通过附加时序约束可以综合布线工具调整映射和布局布线，是设计达到时序要求。

  附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分
  组，对分组附加周期约束，然后对FPGA/CPLD输入输出PAD附加偏移约束、对全组合逻辑的PAD TO PAD路径附加约束。附加专门约束时，首先约束分组之间的路径，
  然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。

***** 附加约束的作用？

  作用：1：提高设计的工作频率（减少了逻辑和布线延时）；2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要求的标准，因 此要求
  设计者正确输入约束，以便静态时序分析工具可以正确的输出时序报告）3：指定FPGA/CPLD的电气标准和引脚位置。

***** FPGA设计工程师努力的方向：

  SOPC， 高速串行I/O，低功耗，可靠性，可测试性和设计验证流程的优化等方面。随着芯片工艺的提高，芯片容量、集成度都在增加，FPGA设计也朝着高速、高度集
  成、低功耗、高可靠性、高可测、可验证性发展。芯片可测、可验证，正在成为复杂设计所必备的条件，尽量在上板之前查出bug，将发现bug的时间提前，这 也是一些
  公司花大力气设计仿真平台的原因。另外随着单板功能的提高、成本的压力，低功耗也逐渐进入FPGA设计者的考虑范围，完成相同的功能下，考虑如何 能够使芯片的功
  耗最低，据说altera、xilinx都在根据自己的芯片特点整理如何降低功耗的文档。高速串行IO的应用，也丰富了FPGA的应用范 围，象xilinx的v2pro中的高速链路也逐渐被
  应用。总之，学无止境，当掌握一定概念、方法之后，就要开始考虑FPGA其它方面的问题了。

***** 对于多位的异步信号如何进行同步？

  对以一位的异步信号可以使用“一位同步器进行同步”，而对于多位的异步信号，可以采用如下方法：1：可以采用保持寄存器加握手信号的方法（多数据，控制， 地址）；
  2：特殊的具体应用电路结构,根据应用的不同而不同 ；3：异步FIFO。（最常用的缓存单元是DPRAM）

***** FPGA和CPLD的区别？

  FPGA是可编程ASIC。

  ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成
  电路。与门阵列等其它ASIC(ApplicaTIon Specific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线
  检验等优点。

  CPLD FPGA
  内部结构 Product－term Look－up Table
  程序存储 内部EEPROM SRAM，外挂EEPROM
  资源类型 组合电路资源丰富 触发器资源丰富
  集成度 低 高
  使用场合 完成控制逻辑 能完成比较复杂的算法
  速度 慢 快
  其他资源 － PLL、RAM和乘法器等
  保密性 可加密 一般不能保密

***** 锁存器（latch）和触发器（flip-flop）区别？

  电平敏感的存储期间称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。

  有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建
  立时间，后一个锁存器则决定了保持时间。

***** FPGA芯片内有哪两种存储器资源？

  FPGA芯片内有两种存储器资源：一种叫block ram,另一种是由LUT配置成的内部存储器（也就是分布式ram）。Block ram由一定数量固定大小的存储块构成的，使用
  BLOCK RAM资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的BLOCK RAM资源是其块大小的整数倍。

***** 什么是时钟抖动？

  时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为0的平均变量。

***** FPGA设计中对时钟的使用？（例如分频等）

  FPGA芯片有固定的时钟路由，这些路由能有减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时 钟的偏
  差FPGA设计中对时钟的使用？（例如分频等）和抖动，还会使时钟带上毛刺。一般的处理方法是采用FPGA芯片自带的时钟管理器如PLL,DLL或DCM，或者把逻辑转换
  到触发器的D输入（这 些也是对时钟逻辑操作的替代方案）。

****** 偶数分频
****** 奇数分频
  由上升沿和下降沿分别产生两个时钟，占空比都不是50\%，两个信号相或，得到占空比50\%
****** 1.5倍分频

***** FPGA设计中如何实现同步时序电路的延时？

  首先说说异步电路的延时实现：异步电路一半是通过加buffer、两级与非门等（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。在同步 电路中，对
  于比较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟 一个时钟周期。

***** FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项？

  三种资源：block ram;触发器（FF），查找表（LUT）；

  注意事项：
  1：在生成RAM等存储单元时，应该首选block ram 资源；其原因有二：第一：使用block ram等资源，可以节约更多的FF和4-LUT等底层可编程单元。使用 block ram可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：block ram是一种可以配置的硬件结构，其可靠性和速度与用LUT和register构 建的存储器更有优势。
  2：弄清FPGA的硬件结构，合理使用block ram资源；
  3：分析block ram容量，高效使用block ram资源；
  4：分布式ram资源（distribute ram）

  RAM是同步的，必须连接clk，读ram必须在时钟上升沿之后，BRAM 具有很高的运行速度，确定的低延迟周期；同时，ram的布线可能造成额外负担

***** Xilinx中与全局时钟资源和DLL相关的硬件原语：

  常用的与全局时钟资源相关的Xilinx器件原语包括：IBUFG,IBUFGDS,BUFG,BUFGP,BUFGCE,BUFGMUX,BUFGDLL,DCM等。关于各个器件原语的解释可以参考
  《FPGA设计指导准则》p50部分。

  xilinx fpga内部的全局时钟采用全铜工艺实现，配合专用时钟缓冲和驱动结构，可以使进入全局时钟网络的时钟到达fpga内部各个逻辑单元的抖动和延迟最小。
  全局时钟资源是专用布线资源，存在于全铜布线层上，使用全局时钟资源不会影响芯片的其他布线资源。最好的全局时钟解决方案是：让时钟从全铜工艺的全局时钟输入管脚进入fpga，然后经内部的全局时钟缓冲单元去控制各个触发器。

  xilinx常用的全局时钟资源原语有：全局时钟缓冲IBUFG、差分全局时钟缓冲IBUFGDS、全局缓冲BUFG、数字时钟管理单元DCM、锁相环PLL。

***** HDL语言的层次概念？

  HDL语言是分层次的、类型的，最常用的层次概念有系统与标准级、功能模块级， *行为级* ，寄存器传输级和门级。

***** 查找表的原理与结构？

  查找表（look-up-table）简称为LUT，LUT本质上就是一个RAM。目前FPGA中多使用4输入的LUT，所以每一个 *LUT可以看成一个有4位地址线的16x1的RAM* 。当用户
  通过原理图或HDL语言描述了一个逻辑电路以后，PLD/FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑
  运算就等于输入一个地址进行查表（编码解码），找出地址对应的内容，然后输出即可

***** ic设计前端到后端的流程和eda工具？

  设计前端也称逻辑设计，后端设计也称物理设计，两者并没有严格的界限，一般涉及到与工艺有关的设计就是后端设计。

  1：规格制定：客户向芯片设计公司提出设计要求。
  2：详细设计：芯片设计公司（Fabless）根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。目前架构的验证一般基于 systemC语言，对价后
    模型的仿真可以使用systemC的仿真工具。例如：CoCentric和Visual Elite等。
  3：HDL编码：设计输入工具：ultra ，visual VHDL等
  4：仿真验证：modelsim
  5：逻辑综合：synplify
  6：静态时序分析：synopsys的Prime Time
  7：形式验证：Synopsys的Formality.
** Self introduction
*** 按部就班的本科
- 课设： 由软件到硬件，打下EE的基础
- 比赛： 西门子杯过程控制大赛
- 实习： 校外实习（施耐德电气），校内实习（大三进入实验室）

*** 寻找自我价值的研究生
- 光纤燃油液位传感器： 传感器性能远超同类传感器。最佳的光纤角度是什么？
- JPEG解码： 最大的throughtput
- 微软实习： 表达自己的想法，与别人灵感碰撞

*** 成果
- 证书：计算机4极网络工程师
- 国家奖学金
- 2篇SCI论文

*** 职业规划
完善EE、CS的功底，解决CS遇到的问题

* Project
** AIPre
*** 面试时描述项目
AIPre的框图，可用于向面试官讲述项目重点
[[file:figures/AIPre.png]]

1. 速度不匹配时采用乒乓操作
由于模块1parser和模块3IDCT都可以fully pipeline，但模块2Huffman Decoder只能用状态机，速度不匹配。
为了使得parser和IDCT不会空闲，使用多个Huffman Decoder，采用乒乓算法，parser的每个图片的输出，送到不同的Huffman Decoder，产生的带有image id和block id的图片送到一个IDCT。

image id在parser每次读入新图片jpeg_data_first_in时，序号加1；
block id在Huffman Decoder处理和8*8block或者遇到EOB时，序号加1.

2. 设计接口
data 和data valid in必须绑定；
data first in必须要有；
data last in不一定要有，除非对最后的数据标志有状态机的需求
data padding in不一定要有，除非数据有效位数难以判断
fifo full in 下一模块是否可以发数据

fifo full out 告诉前一模块是否要发数据

3. 设计流程
- 时序图：模块接口信号，模块内部块的接口信号
- 内部功能块设计block design： 模块的功能，数据流向，实现思路
- 代码实现：
- 功能测试：
- 调频：
- 电路验证：

4. 串行和并行
FPGA进行并行处理时，不是逐字节处理，而是一下处理一大块，只能解决了前面，才能解决后面。
串行可以逐字节处理，前后直接相关
**** JPEG
jpeg是图像文件压缩编码算法
1. 压缩DCT：有损的离散余弦变换
2. 编码Huffman：
压缩算法：IDCT将8*8的block中有效数放在左上角，Huffman将无效的数不表示，将有效的8bit数缩位表示
3. 数据流特点：
数据流---最小编码单元MCU---数据单元与颜色分量YCbCr---颜色分量单元block
一个MCU通常取图片16*16像素点，将其每个像素点RGB转换YCbCr，得到Y16*16, Cb16*16,Cr16*16，通过下采样4:1:1，将16*16分为4个8*8，得到Y[1]8*8，Y[2]8*8，Y[3]8*8，Y[4]8*8，Cb8*8，Cr8*8。之后都以8*8的数据进行压缩处理。

颜色分量单元内部综合运用了 RLE 行程编码和哈夫曼编码来压缩数据
**** Parser
1. DQT：tag+length+table（64*8bit）
2. DHT：tag+length+count（count转化为huffman表）
3. image： FF{00} --> FF, FF{FF}_n{xx} --> FF后跟一个tag{xx}, FF{D0~D7}: RSTn, FF{D9} EOI, FF{xx} --> xx

**** Huffman
哈夫曼编码的关键是如何降低哈夫曼编码树的存储空间。
范式哈夫曼编码要求，码字是连续二进制，长度不变时，加1；长度增加时，加1再添0。
JPEG中DHT中位置为n存储的是长度为n的码字数量，最长为16。由此可得到huffman表

**** IDCT
把频域转为色域的数

1 8*8bit 2D-IDCT ==> 8 8bit 1D-IDCT--> transpose -->8 8bit 1D-IDCT --> transpose

**** 性能
- 最大频率400M
- 完全pipeline
- 比上一代增快一倍
- 比常见快30%
