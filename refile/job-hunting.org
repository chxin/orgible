#+STARTUP: content

* Reading Milestone
** software basic knowledge [4/4]

  - [X] C++ primer
  - [X] algorithm introduction
  - [X] network
  - [X] architecture

** hardware basic knowledge [1/2]

  - [-] FPGA [1/4]
    - [ ] 可重构计算
    - [X] 高性能 FPGA 系统--时序设计与分析
    - [ ] [[https://www.zhihu.com/pub/reader/119600245/chapter/1084498804891475968][FPGA芯片架构设计与实现]]
    - [ ] Altera FPGA CPLD 设计-高级篇
    - [ ] [[https://www.icourse163.org/learn/SWJTU-1207492806?tid=1207824209#/learn/content][MOOC:FPGA硬件加速设计方法]]
    - [ ] [[https://zhuanlan.zhihu.com/c_1249458908361302016][FPGA基础架构]]
    - [ ] [[https://mp.weixin.qq.com/s/-Lu4HFVGpZA6edlGodtD8A][FPGA面试题100道]]
  - [X] Digital Circuit

* Milestone
** DONE Leetcode [[/Users/xin/Documents/Leetcode/makefile][workspace]]
   CLOSED: [2020-07-02 Thu 19:10]

*** DONE leetcode daily
    :PROPERTIES:
    :STYLE:    habit
    :REPEAT_TO_STATE: DONE
    :LAST_REPEAT: [2020-07-15 Wed 09:07]
    :LAST_REPEAT: [2020-06-06 Sat 13:45]
    :ID:       5FB13F87-D183-41D8-A027-006D6073F9B0
    :END:
    - State "DONE"       from "NEXT"       [2020-06-06 Sat 13:45]
    - State "DONE"       from "NEXT"       [2020-06-05 Fri 13:37]
    - State "DONE"       from "NEXT"       [2020-06-04 Thu 14:52]
    - State "DONE"       from "NEXT"       [2020-05-31 Sun 19:12]
    - State "DONE"       from "NEXT"       [2020-05-30 Sat 13:32]
    - State "DONE"       from "NEXT"       [2020-05-29 Fri 13:56]
    - State "DONE"       from "NEXT"       [2020-05-27 Wed 21:43]
    - State "DONE"       from "NEXT"       [2020-05-25 Mon 21:23]
    - State "DONE"       from "NEXT"       [2020-05-23 Sat 16:55]
    - State "DONE"       from "NEXT"       [2020-05-09 Sat 15:07]
    - State "DONE"       from "NEXT"       [2020-05-08 Fri 13:25]
    - State "DONE"       from "NEXT"       [2020-05-06 Wed 13:58]
    - State "DONE"       from "NEXT"       [2020-05-05 Tue 13:25]
    - State "DONE"       from "NEXT"       [2020-05-04 Mon 17:31]
    - State "DONE"       from "NEXT"       [2020-04-16 Thu 13:51]
    - State "DONE"       from "NEXT"       [2020-04-15 Wed 14:21]
    - State "DONE"       from "NEXT"       [2020-04-14 Tue 11:14]
    - State "DONE"       from "NEXT"       [2020-04-10 Fri 15:15]
    - State "DONE"       from "NEXT"       [2020-04-06 Mon 13:20]
    - State "DONE"       from "NEXT"       [2020-04-05 Sun 14:27]
    - State "DONE"       from "NEXT"       [2020-04-04 Sat 14:22]
    - State "DONE"       from "NEXT"       [2020-04-03 Fri 13:37]
    - State "DONE"       from "NEXT"       [2020-04-01 Wed 15:10]
    - State "DONE"       from "NEXT"       [2020-03-30 Mon 14:01]
    - State "DONE"       from "NEXT"       [2020-03-29 Sun 14:15]
    - State "DONE"       from "NEXT"       [2020-03-28 Sat 17:28]
    - State "DONE"       from "NEXT"       [2020-03-27 Fri 16:34]
    - State "DONE"       from "NEXT"       [2020-03-24 Tue 13:11]
    - State "DONE"       from "NEXT"       [2020-03-23 Mon 20:31]
    - State "done"       from ""           [2020-03-05 Thu 17:00]
    [2020-03-05 Thu 11:19]

    SCHEDULED: <2020-06-30 Tue 13:30 .+1d/2d>
    :PROPERTIES:
    :STYLE: habit
    :REPEAT_TO_STATE: NEXT
    :END:
*** DONE leetcode solution
    CLOSED: [2020-07-02 Thu 18:50]

从 Leetcode 中精选大概 200 左右的题目，去除了某些繁杂但是没有多少算法思想的题目，同时保留了面试中经常被问到的经典题目。

**** 数据结构相关

   1. [[file:~/Documents/Leetcode/note/Leetcode-%E9%93%BE%E8%A1%A8.org][链表]]
   2. [[file:~/Documents/Leetcode/note/Leetcode-%E6%A0%91.org][树]]
   3. [[file:~/Documents/Leetcode/note/Leetcode-栈和队列.org][栈和队列]]
   4. [[file:~/Documents/Leetcode/note/Leetcode-哈希表.org][哈希表]]
   5. [[file:~/Documents/Leetcode/note/Leetcode-字符串.org][字符串]]
   6. [[file:~/Documents/Leetcode/note/Leetcode-数组与矩阵.org][数组与矩阵]]
   7. [[file:~/Documents/Leetcode/note/Leetcode-图.org][图]]
   8. [[file:~/Documents/Leetcode/note/Leetcode-位运算.org][位运算]]

**** 算法思想

   1. [[file:~/Documents/Leetcode/note/Leetcode-双指针.org][双指针]]
   2. [[file:~/Documents/Leetcode/note/Leetcode-排序.org][排序]]
   3. [[file:~/Documents/Leetcode/note/Leetcode-贪心思想.org][贪心思想]]
   4. [[file:~/Documents/Leetcode/note/Leetcode-二分查找.org][二分查找]]
   5. [[file:~/Documents/Leetcode/note/Leetcode-分治.org][分治]]
   6. [[file:~/Documents/Leetcode/note/Leetcode-搜索.org][搜索]]
   7. [[file:~/Documents/Leetcode/note/Leetcode-动态规划.org][动态规划]]
   8. [[file:~/Documents/Leetcode/note/Leetcode-数学.org][数学]]

**** 参考资料

   1. Leetcode
   2. Weiss M A, 冯舜玺. 数据结构与算法分析------C 语言描述[J]. 2004.
   3. Sedgewick R. Algorithms[M]. Pearson Education India, 1988.
   4. 何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014.
   5. 《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008.
   6. 左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.

** DONE FPGA daily [[*FPGA interviews][workspace]] [[https://hdlbits.01xz.net/wiki/Problem_sets][problems set]]
 SCHEDULED: <2020-09-30 Wed .+1d>
 :PROPERTIES:
 :STYLE: habit
 :REPEAT_TO_STATE: DONE
 :LAST_REPEAT: [2020-09-30 Wed 10:43]
 :END:
 - State "DONE"       from "NEXT"       [2020-09-30 Wed 10:43]
 - State "DONE"       from "NEXT"       [2020-09-30 Wed 10:43]
 - State "DONE"       from "NEXT"       [2020-09-13 Sun 11:42]
 - State "DONE"       from "NEXT"       [2020-09-13 Sun 11:42]
 - State "DONE"       from "NEXT"       [2020-09-07 Mon 11:25]
 - State "DONE"       from "NEXT"       [2020-08-29 Sat 09:36]
 - State "DONE"       from "NEXT"       [2020-08-10 Mon 11:08]
 - State "DONE"       from "NEXT"       [2020-08-08 Sat 21:58]
 - State "DONE"       from "NEXT"       [2020-08-07 Fri 21:30]
 - State "DONE"       from "NEXT"       [2020-08-06 Thu 20:55]
*** Notes
**** DONE 100.FPGA 开发流程
     CLOSED: [2020-08-06 Thu 21:04]
需求分析 --> 功能定义/器件选型 --> HDL 输入（模块，接口及时序，子模块） --> 功能仿真（时序仿真器） --> 综合优化（逻辑综合器） --> 逻辑仿真（综合，逻辑仿真器） --> *映射* 和布局布线（FPGA 厂家工具） --> 时序分析（静态时序分析） --> 芯片编程与调试
**** DONE 97.FPGA 性能指标
     CLOSED: [2020-08-06 Thu 21:20]
C 语言和 HDL 的的根本区别：一个顺序执行，一个并行执行。C没有时序的概念，HDL 的灵魂是时序
使用时序而长组合逻辑的原因：不同的走线会导致竞争冒险，时序可以减少毛刺
- 工作频率
- 延迟
- 吞吐量
- 数据率
**** DONE 89.二进制乘除法
     CLOSED: [2020-08-29 Sat 10:27]
***** 乘法
移位加法

可以性能优化，多个寄存器直接赋值为移位后的值，然后相加，一个时钟就可以完成。
***** 除法
除数逐次向右移位，被除数减去除数，如果首位是 1，如果首位是 0
1 个 64bit 余数寄存器，保存被除数；1个 32bit 除数寄存器，带右移功能；1个 32bit 商寄存器，带左移功能；一个 64bit 加减法器。
循环执行 32 次

优化除法器：
除数寄存器缩小为 32bit，无需移位；取消商寄存器；余数寄存器 64bit，支持左移，只有高 32bit 参与运算，商放在除数寄存器的低 32bit；一个 32bit 加减法器。

无法进行性能优化
**** DONE 87.乘加运算
     CLOSED: [2020-08-29 Sat 09:49]
Altera 有固定的 IP 核来检测和实现乘加操作，一般就是 DSP；
1. 串行：乘累加
   mul <= a * b;
   sum <= sum + mul;
2. 并行：加法树
   多个乘法值并行输入，后面通过加法树两两逐层连结起来
**** DONE 68.加减计数器
     CLOSED: [2020-08-10 Mon 11:08]
#+begin_src verilog
module verset_updown_counter {
                              input        clk,
                              input        rst_n,
                              input        new_counter_preset,
                              input [7:0]  preset_value,
                              input        counter_up_enable,
                              input        counter_down_enable,
                              input        pause_counter,
                              output       counter_expired,
                              output [7:0] count
                              };

    reg                                    preset_value_stored;
    always @ (posedge clk) begin
        if(new_counter_preset) begin
            preset_value_stored <= preset_value;
        end
    end

    // 输入的优先级：pause, up_start, up(down); preset
    reg                                    counter_up_enable_reg;
    reg                                    counter_down_enable_reg;
    always @ (posedge clk) begin
        counter_up_enable_reg   <= counter_up_enable;
        counter_down_enable_reg <= counter_donw_enable;
    end

    reg                                    counter_up_start;
    reg                                    counter_down_start;
    assign counter_up_start = counter_up_enable & (!counter_up_enable_reg);
    assign counter_down_start = counter_down_enable & (!counter_down_enable_reg);

    always @ (posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            count <= preset_value_stored;
        end else begin
            if(pause) begin
                count <= count;
            end else begin
                counter_expired <= 1'b0;
                if(counter_up_start) begin
                    count <= 8'h0;
                end else begin
                    if(counter_down_start) begin
                        count <= 8'hffff;
                    end else begin
                        if(counter_up_enable) begin
                            count    <= count + 1;
                            if(count == 8'hffff) begin
                                count           <= preset_value_stored;
                                counter_expired <= 1'b1;
                            end
                        end else begin
                            if(counter_down_enable) begin
                                count <= count - 1;
                                if(count == 8'h0) begin
                                    count <= preset_value_stored;
                                    counter_expired <= 1'b1;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

endmodule; // verset_updown_counter
#+end_src
**** DONE 60.RAM
      CLOSED: [2020-08-10 Mon 10:35]
***** DONE 27.BRAM 写模式
      写模式：读写冲突
***** DONE 60.单口 RAM
    只有一套接口：地址线、时钟、写总线、读总线。
    不同 verilog 会综合出不同的 RAM
    - 发生冲突
      - no change：每个时钟，只会发生读或者写。
      - read first：if(en) out <= RAM[addr]; if(en & wr_en) RAM[addr] <= in
      - write first：if(en && !wr_en) out <= RAM[addr]; if(en && wr_en) RAM[addr] <= in out <= in

    /FPGA 提供的 RAM 只支持同步读/

    - 读逻辑
      - 异步读: assign out = RAM[addr]
      - 伪同步读: always @ (posedge clk) out <= RAM[addr]
      - 真同步读: always @ (posedge clk) addr_lock <= addr; assign out = RAM[addr_lock]
***** DONE 61.双口 RAM
    两套接口：尤其是两个时钟
    - A 写 B 读
    - 全双口异步读
**** DONE 47.function vs task
     CLOSED: [2020-08-07 Fri 18:27]
task 和 function 往往是在大的程序模块中且在不同地点多次用到的相同程序段。
task 和 function 都不支持时序操作，只能够得到组合电路。module 可以得到时序电路

Verilog HDL 模块使用 function 时，则把它当做逻辑运算操作符，这个操作的结果值就是这个 function 的返回值；
task 的输出或总线端口送出；task 的输入输出必须是寄存器类型，因此调用必须在 initial 块中或者 always 块中
不同：
1. function 只能与主模块共用同一个仿真时间单位，而 task 可以定义自己的仿真时间单位。
2. function 不能启动 task，而 task 能启动其他 task 和 function。
3. function 只是需要一个输入变量，而 task 可以没有或有多个任何类型的变量。
4. function 返回一个值，而 task 则不返回值。

**** DONE 43.异步 FIFO
     CLOSED: [2020-08-10 Mon 08:27] SCHEDULED: <2020-08-09 Sun 08:30>
异步 FIFO 基于双端口 RAM.
1. 空满标志位
   目的：任何情形下，都不出现同时读写同一个内存地址。

   在 FIFO 中，维持 FIFO 大小的是 rd_addr 和 wr_addr，每次读写(wr_en && !full) (rd_en && !empty)都会递增这两个值。通常 wr_addr 要大于 rd_addr。
   但是，由于固定位数的地址在递增可能会超过最大值而变成 0，所以，rd_addr 和 wr_addr 并没有绝对的大小关系。
   所以，不能根据地址减法来判断 FIFO 的存了多少数据。同时，减法运算很耗时，会影响 FIFO 的效率。

   - 设置标志位：
   满状态：在写时钟的上升沿，进行了有效的写操作，wr_addr 追上 rd_addr；
   空状态：在读时钟的上升沿，进行了有效的读操作，rd_addr 追上 wr_addr。

   满和空，都是判断 rd_addr==wr_addr，能否直接这样判断？
   不能，因为这样判断不能判断是空还是满。应该是 rd_addr_next== wr_addr 判断空，wr_addr_next == rd_addr 判断满。

   同时，这样暴露一个严重问题：rd_addr 和 wr_addr 是不同时钟域的信号，不能直接比较。需要跨时钟打两拍之后才能比较。

   - 什么时候清楚标志位，什么时候保持标志位？
     *在 rd_addr_next != wr_addr && rd_addr != wr_addr，清除标志位。其它时间保持*
2. 地址编码
   使用格雷码，进行地址比较，尤其是跨时钟的时候。

   gray_code[N:0]= bin_code ^ {1'b0, bin[N:1}

**** DONE 36.溢出判断
     CLOSED: [2020-08-07 Fri 20:31]
1. 单符号位法
   当操作数的符号位相同时，若结果的符号位与操作数的符号位不一致，表示溢出
2. 双符号位法
在运算数前面加 2 个符号位，正数加 00，负数加 11。运算结果的双符号位进行异或，若为 1 则发生溢出，若为 0 则没有发生溢出。最高位一定是结果的正确的符号位。
**** DONE 5.同步复位和异步复位
     CLOSED: [2020-10-05 Mon 09:48]
以下分析仅针对于不经过优化的综合器，现在的综合器很智能，可以根据 verilog 风格和指令进行恰当的优化
1. 同步复位
   verilog 表示同步复位 always @ (posedge clk) if(!rst_n)。
   综合之后的结果，rst_n 作为与原输入做与逻辑，然后送到 DFF 的输入端，DFF 的 CLR 端没有连结。
   1. 优点：
      - 有利于仿真器的综合，有利于时序分析，综合的 Fmax 较高
      - 复位操作仅在时钟上升沿触发，可以滤除毛刺
   2. 缺点：
      - 浪费逻辑资源
      - 复位信号必须大于时钟周期（不能在两个上升沿之间）才有效
2. 异步复位
   异步复位的最大问题是，复位信号拉高的时候可能出现亚稳态
   verilog 表示异步复位 always @ (posedge clk or negedge rst_n) if(!rst_n)
   综合之后的结果，rst_n 直接与 DFF 的 CLR 相连
   1. 优点：
      - 设计简单，节省资源，可以直接使用 DFF 的 CLR 端
      - 不依赖于时钟，复位信号识别方便
   2. 缺点：
      - 异步信号，在释放的时候出现时序违例（rst_n 的上升沿在 DFF 的建立时间和保持时间之内），导致亚稳态
      - 对毛刺敏感
3. 异步复位同步释放
   https://blog.csdn.net/qq_15062763/article/details/90904439
   同步释放是指把复位信号拉高的时间和时钟上升沿一致，复位信号拉低的时间不管。
   这样设计是由于 FPGA 有较多的 DFF，但组合逻辑资源很少。
   用 verilog 表示 always @ (posedge clk or negedge rst_n) if(!rst_n)...    *always @ (posedge clk) rst_n <= rst* （错误，太短的 rst_n 信号不敏感）;
   基本思想是把输入的 rst 信号在同步时钟下打两拍，得到和时钟同步的信号。但这里打两拍不是把 rst 信号放到 DFF 输入端，而是连结到 CLR 端，只控制复位信号拉高的时机。
   综合之后，既有同步的复位信号，又可以直接连 DFF 的 CLR 端。
**** DONE 亚稳态
     CLOSED: [2020-10-05 Mon 09:49]
只要系统中有异步元件，亚稳态就无法避免。
亚稳态主要发生在：异步信号检测、跨时钟域信号传输、复位电路。
亚稳态的主要危害是，亚稳态会传播，导致系统错误。

如何在写 HDL 时，敏感察觉到异步信号：
通过 always @()语句，可以看到所有的敏感信号，除了 clk，所有的其他信号都要考虑异步。
避免使用 always @ (*)，写出完成的敏感信号列表

1. 异步信号处理
   多个 D 触发器级联，在同一时钟域下
   异步复位，同步释放
2. 跨时钟域
   多个触发器级联（注意由快到慢，需要信号扩展）
   异步 FIFO
   握手

**** DONE 复位电路
     CLOSED: [2020-10-05 Mon 09:49]
https://zhuanlan.zhihu.com/xchip
** Knowledge
*** DONE FPGA interviews
    CLOSED: [2020-10-05 Mon 09:49]

  1. https://blog.nowcoder.net/n/0a68e0a09141471a98bf2a2cec51af3a 面经：公司岗位，面试题
  2. https://mp.weixin.qq.com/s/-Lu4HFVGpZA6edlGodtD8A  FPGA 笔试面试 100 道
  3. https://blog.csdn.net/Reborn_Lee/article/details/100049997?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 芯片设计与时序
  4. https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247484417&idx=2&sn=ff8858e65f055acc2d63e4515cb9a505&chksm=cf0b8826f87c0130cdc9abd07fc00ba0591e04b056951dcd88e1b40ba1baf759b24b48217794&scene=21#wechat_redirect verilog 语句的门电路

**** compnay
***** ASIC 工程师面试经验分享

     - 商汤（一共 4 面，全程微信语音）- FPGA 自动驾驶优化验证
     - 百度（一共 3 面，全程微信）- 芯片验证
     - 寒武纪（一共 3 面）- 芯片验证
     - 华为海思（一共 3 面）- 芯片
     - 在面经下的问答

***** 数字芯片设计工程师面试经验（实习加校招）

     - 腾讯实习（量子实验室）
     - 华为实习
     - 华为海思秋招面经
     - 寒武纪
     - vivo

***** 2020 校招芯片设计工程师面经

     - 寒武纪（芯片设计）一面挂
     - akuna capital（FPGA 开发）二面挂
     - 百度（芯片验证）三面挂
     - 华为（海思数字芯片）拿了 offer
     - 英伟达（FPGA/Emu）拿了 offer
     - OPPO（芯片设计）拿了 offer

***** 2019 数字 IC 求职笔记（涵盖十余家国内一流 IC 公司）

     - 华为
     - 兆芯
     - 全志科技
     - 寒武纪
     - 格科微电子
     - 比特大陆
     - Cadence&AMD
     - 大疆

**** questions
***** 什么是同步逻辑和异步逻辑？（汉王）

  同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。答案应该与上面问题一致

  〔补充〕：同步时序逻辑电路的特点：各触发器的时钟端全部连接在一起，并接在系统时钟端，只有当时钟脉冲到来时，电路的状态才能改变。改变后的状态将一直保持到下一个时钟脉冲的到来，此时无论外部输入 x 有无变化，状态表中的每个状态都是稳定的。

  异步时序逻辑电路的特点：电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外部输入的变化直接引起。

***** 同步电路和异步电路的区别

  同步电路：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。

  异步电路：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，这有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同步。

***** 时序设计的实质

  电路设计的难点在时序设计，时序设计的实质就是满足每一个触发器的建立/保持时间的而要求。

***** 建立时间与保持时间的概念？

  建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的时间。

  保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的时间。

  不考虑时钟的 skew，D2 的建立时间不能大于（时钟周期 T - D1 数据最迟到达时间 T1max+T2max）；保持时间不能大于（D1 数据最快到达时间 T1min+T2min）；否则 D2 的数据将进入亚稳态并向后级电路传播

***** 为什么触发器要满足建立时间和保持时间？

  因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在 0 和 1 之间变化，这时 需
  要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入 信号对
  于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。

  （比较容易理解的方式）换个方式理解：需要建立时间是因为触发器的 D 端像一个锁存器在接受数据，为了稳定的设置前级门的状态需要一段稳定时间；需要保持时间是因为在时钟沿到来之后，触发器要通过反馈来锁存状态，从后级门传到前级门需要时间。

***** 什么是亚稳态？为什么两级触发器可以防止亚稳态传播？

  这也是一个异步电路同步化的问题。 用一个时钟周期来使亚稳态生成稳定输出。

  亚稳态是指触发器无法在某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一步同位器”，他只能用来对一位异步信号进行同步。
  两级触发器可防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 < = 时钟周期。

  更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没有作用 。

***** 系统最高速度计算（最快时钟频率）和流水线设计思想：

  同步电路的速度是指同步系统时钟的速度，同步时钟愈快，电路处理数据的时间间隔越短，电路在单位时间内处理的数据量就愈大。

  假设 Tco 是触发器的输入数据 被时钟 打入到触发器到数据到达触发器输出端的延时时间；Tdelay 是组合逻辑的延时；Tsetup 是Ｄ触发器的建立时间。假设数据已被时钟打入 D 触发 器，那么数据到达第一个触 发器的Ｑ输出端需要的延时时间是 Tco，经过组合逻辑的延时时间为 Tdelay，然后到达第二个触发器的Ｄ端，要希望时钟能在第 二个触发器再次被稳定地打入触发器，
  则时钟的延迟必须大于 Tco＋Tdelay＋Tsetup，也就是说最小的时钟周期 Tmin =Tco＋Tdelay＋Tsetup，即最快的时钟频率 Fmax =1/Tmin。
  FPGA 开发软件也是通过这种方法来计算系统最高运行速度 Fmax。因为 Tco 和 Tsetup 是由具体的器件工艺决定的，故设计电路时只能改变组合逻辑的延迟时间 Tdelay，所以说缩短触发器间组合逻辑的延时时间是提高同步电路速度的关键所在。

  由于一般同步电路都大于一级锁存，而要使电路稳定工作，时钟周期必须满足最大延时要求。故只有缩短最长延时路径，才能提高电路的工作频率。可以将较大的组合逻辑分解为较小的 N 块，通过适当的方法平均分配组合逻辑，然后在中间插入触发器，并和原触发器使用相同的时钟，就可以避免在两个触发器之间出现过大的延时，消除速度瓶颈，这样可以提高电路的工作频率。这就是所谓"流水线"技术的基本设计思想，即原设计速度受限部分用一个时钟周期实现，采用流水线技术插入触发器后，可用 N 个时钟周期实现，因此系统 的工作速度可以加快，吞吐量加大。注意，流水线设计会在原数据通路上加入延时，另外硬件面 积也会稍有增加。

***** 时序约束的概念和基本策略？

  时序约束主要包括 *周期约束，偏移约束，静态时序路径约束* 三种。通过附加时序约束可以综合布线工具调整映射和布局布线，是设计达到时序要求。

  附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分组，对分组附加周期约束，然后对 FPGA/CPLD 输入输出 PAD 附加偏移约束、对全组合逻辑的 PAD TO PAD 路径附加约束。附加专门约束时，首先约束分组之间的路径，
  然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。

***** 附加约束的作用？

  作用：1：提高设计的工作频率（减少了逻辑和布线延时）；
  2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要求的标准，因此要求设计者正确输入约束，以便静态时序分析工具可以正确的输出时序报告）
  3：指定 FPGA/CPLD 的电气标准和引脚位置。

***** FPGA 设计工程师努力的方向：

  SOPC， 高速串行 I/O，低功耗，可靠性，可测试性和设计验证流程的优化等方面。随着芯片工艺的提高，芯片容量、集成度都在增加，FPGA 设计也朝着高速、高度集
  成、低功耗、高可靠性、高可测、可验证性发展。芯片可测、可验证，正在成为复杂设计所必备的条件，尽量在上板之前查出 bug，将发现 bug 的时间提前，这 也是一些
  公司花大力气设计仿真平台的原因。另外随着单板功能的提高、成本的压力，低功耗也逐渐进入 FPGA 设计者的考虑范围，完成相同的功能下，考虑如何 能够使芯片的功
  耗最低，据说 altera、xilinx 都在根据自己的芯片特点整理如何降低功耗的文档。高速串行 IO 的应用，也丰富了 FPGA 的应用范 围，象 xilinx 的 v2pro 中的高速链路也逐渐被
  应用。总之，学无止境，当掌握一定概念、方法之后，就要开始考虑 FPGA 其它方面的问题了。

***** 对于多位的异步信号如何进行同步？

  对以一位的异步信号可以使用“一位同步器进行同步”，而对于多位的异步信号，可以采用如下方法：1：可以采用保持寄存器加握手信号的方法（多数据，控制， 地址）；
  2：特殊的具体应用电路结构,根据应用的不同而不同 ；3：异步 FIFO。（最常用的缓存单元是 DPRAM）

***** FPGA 和 CPLD 的区别？

  FPGA 是可编程 ASIC。

  ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。
  与门阵列等其它 ASIC(ApplicaTIon Specific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点。

  CPLD FPGA
  内部结构 Product－term Look－up Table
  程序存储 内部 EEPROM SRAM，外挂 EEPROM
  资源类型 组合电路资源丰富 触发器资源丰富
  集成度 低 高
  使用场合 完成控制逻辑 能完成比较复杂的算法
  速度 慢 快
  其他资源 － PLL、RAM 和乘法器等
  保密性 可加密 一般不能保密

***** 锁存器（latch）和触发器（flip-flop）区别？

  电平敏感的存储期间称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。

  有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。
  1. FPGA 级别：配置存储器生成 Latch 或者 FF
  2. verilog 级别：时序与组合电路，上升沿和电平，完备 if else
  3. 数电级别：电路，把 CLK（CLK 产生的控制信号）接到 RESET

***** FPGA 芯片内有哪两种存储器资源？

  FPGA 芯片内有两种存储器资源：一种叫 block ram,另一种是由 LUT 配置成的内部存储器（也就是分布式 ram）。Block ram 由一定数量固定大小的存储块构成的，使用 BLOCK RAM 资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的 BLOCK RAM 资源是其块大小的整数倍。
  HDL 生成 BRAM，需要同步时钟，大容量

***** 什么是时钟抖动？

  时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为 0 的平均变量。

***** FPGA 设计中对时钟的使用？（例如分频等）

  FPGA 芯片有固定的时钟路由，这些路由能有减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时钟的偏
  差 FPGA 设计中对时钟的使用？（例如分频等）和抖动，还会使时钟带上毛刺。一般的处理方法是采用 FPGA 芯片自带的时钟管理器如 PLL,DLL 或 DCM，或者把逻辑转换
  到触发器的 D 输入（这 些也是对时钟逻辑操作的替代方案）。

****** 偶数分频
****** 奇数分频

  由上升沿和下降沿分别产生两个时钟，占空比都不是 50\%，两个信号相或，得到占空比 50\%

****** 1.5 倍分频
***** FPGA 设计中如何实现同步时序电路的延时？

  首先说说异步电路的延时实现：异步电路一半是通过加 buffer、两级与非门等（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。
  在同步电路中，对于比较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟一个时钟周期。

***** FPGA 中可以综合实现为 RAM/ROM/CAM 的三种资源及其注意事项？

  三种资源：block ram;触发器（FF），查找表（LUT）；

  注意事项：
  1：在生成 RAM 等存储单元时，应该首选 block ram 资源；其原因有二：第一：使用 block ram 等资源，可以节约更多的 FF 和 4-LUT 等底层可编程单元。使用 block ram 可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：block ram 是一种可以配置的硬件结构，其可靠性和速度与用 LUT 和 register 构 建的存储器更有优势。
  2：弄清 FPGA 的硬件结构，合理使用 block ram 资源；
  3：分析 block ram 容量，高效使用 block ram 资源；
  4：分布式 ram 资源（distribute ram）

  RAM 是同步的，必须连接 clk，读 ram 必须在时钟上升沿之后，BRAM 具有很高的运行速度，确定的低延迟周期；同时，ram 的布线可能造成额外负担

***** Xilinx 中与全局时钟资源和 DLL 相关的硬件原语：

  常用的与全局时钟资源相关的 Xilinx 器件原语包括：IBUFG,IBUFGDS,BUFG,BUFGP,BUFGCE,BUFGMUX,BUFGDLL,DCM 等。关于各个器件原语的解释可以参考
  《FPGA 设计指导准则》p50 部分。

  xilinx fpga 内部的全局时钟采用全铜工艺实现，配合专用时钟缓冲和驱动结构，可以使进入全局时钟网络的时钟到达 fpga 内部各个逻辑单元的抖动和延迟最小。
  全局时钟资源是专用布线资源，存在于全铜布线层上，使用全局时钟资源不会影响芯片的其他布线资源。最好的全局时钟解决方案是：让时钟从全铜工艺的全局时钟输入管脚进入 fpga，然后经内部的全局时钟缓冲单元去控制各个触发器。

  xilinx 常用的全局时钟资源原语有：全局时钟缓冲 IBUFG、差分全局时钟缓冲 IBUFGDS、全局缓冲 BUFG、数字时钟管理单元 DCM、锁相环 PLL。

***** HDL 语言的层次概念？

  HDL 语言是分层次的、类型的，最常用的层次概念有系统与标准级、功能模块级， *行为级* ，寄存器传输级和门级。

***** 查找表的原理与结构？

  查找表（look-up-table）简称为 LUT，LUT 本质上就是一个 RAM。目前 FPGA 中多使用 4 输入的 LUT，所以每一个 *LUT 可以看成一个有 4 位地址线的 16x1 的 RAM* 。当用户
  通过原理图或 HDL 语言描述了一个逻辑电路以后，PLD/FPGA 开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入 RAM,这样，每输入一个信号进行逻辑
  运算就等于输入一个地址进行查表（编码解码），找出地址对应的内容，然后输出即可

***** ic 设计前端到后端的流程和 eda 工具？

  设计前端也称逻辑设计，后端设计也称物理设计，两者并没有严格的界限，一般涉及到与工艺有关的设计就是后端设计。

  1：规格制定：客户向芯片设计公司提出设计要求。
  2：详细设计：芯片设计公司（Fabless）根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。目前架构的验证一般基于 systemC 语言，对价后
    模型的仿真可以使用 systemC 的仿真工具。例如：CoCentric 和 Visual Elite 等。
  3：HDL 编码：设计输入工具：ultra ，visual VHDL 等
  4：仿真验证：modelsim
  5：逻辑综合：synplify
  6：静态时序分析：synopsys 的 Prime Time
  7：形式验证：Synopsys 的 Formality.

**** DONE 芯片设计时序问题
     CLOSED: [2020-10-05 Mon 09:49]
   https://blog.csdn.net/Reborn_Lee/article/details/100049997?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

对于建立时间而言，从单独的对触发器的建立时间和保持时间的分析到了对 *电路（系统）的建立时间到保持时间的分析* ，前者是核心，后者是扩展，后者建立在前者的基础之上进行推到得到，同时也是芯片内部实际遵循的时序规则。

建立时间就是时钟有效沿到来之前数据必须保持稳定的时间，而保持时间就是时钟有效沿到来之后数据必须保持稳定的时间，如果不满足建立时间或保持时间，就会导致时序违规，这对电路的功能实现是有很大影响的。
Tco 这个时序参数，是数据输出延时，它是对于触发器而言的，含义是从触发器的时钟有效开始，数据从输入到输出之间的延迟，包括寄存器延时+传输延时+组合逻辑延时。（触发器的数据输入到输出是有一段时间的，所以有这么一个说法，采样反应更快的触发器可以改善时序）

时钟偏斜对于建立时间和保持时间的影响，例如 *正时钟偏斜* 对于建立时间的满足是有帮助的，而对保持时间的满足是有害的。

我们还可以得知，对于组合逻辑的延迟，也即触发器之间的门延迟，不能太大，也不能太小，太大会导致（关键路径）建立时间不满足， *太小会导致（关键路径）保持时间不满足* 。

***** 例题一：建立保持时间计算
有了这些基础，我们从最简单的考题分析：
https://img-blog.csdnimg.cn/20190805215023598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYm9ybl9MZWU=,size_16,color_FFFFFF,t_70

这个题目堪称经典中的经典，因为从这个题目是标准的建立时间和保持时间考题，并从中可以总结出系统最大时钟频率以及建立时间和保持时间需
要满足的公式。

我们知道系统周期需要满足的条件是：

Tcycle + Tskew > Tco + Tgate + Tsu;

代入上面的条件，得知

Tcycle + T5 > T1 + T2 + T3 + T4 + Tsetup

上面的时钟路径是存在偏斜的，而且是正时钟偏斜，则对于保持时间的满足更加的困难，需要满足：

Thold + Tskew < Tc0 + Tgate

代入上面的条件，得： Thold + T5 < T1 + T2 + T3 + T4

***** 例题二：触发器的最高频率

在上题的基础上，你也许会分析触发器的建立时间和保持时间应该满足的关系了，可是考题也许会变了法的考你，如下：
https://img-blog.csdnimg.cn/20190805205919276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYm9ybl9MZWU=,size_16,color_FFFFFF,t_70

求系统的最高频率？

就一个触发器，我怎么办呢？

仔细看来，这是一个触发器到自身的反馈，可以看做两个触发器之间进行数据传输，其实也就是如此。

需要明白的是，由于时钟到达这个触发器的时间一致，所以不存在时钟偏斜。

给出系统周期满足的关系：

Tcycle > Tco + Tgate + Tsu = 6 + 2 + 2= 10ns

所以时钟最大频率可以为 100MHz。

***** 例题三：系统的建保时间

如果都是分析触发器的建立时间和保持时间就好了，可惜不是这样的，套路来了：

如下图，将框内的电路作为一个寄存器，那么其有效的建立时间和保持时间是多少？
https://img-blog.csdnimg.cn/20190824112809339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYm9ybl9MZWU=,size_16,color_FFFFFF,t_70

求框内电路的有效建立时间和保持时间，给出了框内触发器的建立时间和保持时间以及其他一些逻辑的延迟，我们就以触发器的建立时间和保持时
间为准来倒逼整个电路的建立时间和保持时间，一切还都是为了让触发器满足时序要求。

所以考虑时钟输入和输入输入的关系。可以从触发器的关系中根据延时关系推导出来，数据保持时间和时钟上升沿一画出来，一目了然。
有效建立时间分析：

假设电路的有效 Setup 为 Tsetup_valid：

对于 D 触发器而言，其本身的建立时间是 2ns，也就是说数据必须在时钟有效沿到达之前 2ns 保持稳定，这样到达 D 端后就一定是稳定的数据了。

这个电路的数据来自于 IN，时钟来自于 CLK；

考虑时钟路径延迟影响：

时钟 CLK 要早于触发器的时钟 1ns 到达，因此对于 D 触发器建立时间的满足是有害的，电路有效建立时间

Tsetup_valid = Tsetup - 1ns = 1ns（因为数据需要提前 1ns 稳定下来）

考虑数据路径延迟影响：

Tsetup_valid = Tsetup - 1ns + 2ns = 3ns；（经过组合逻辑后的数据需要在时钟有效沿之前 Tsetup 时间稳定下来）

有效保持时间分析：

和建立时间分析套路一致，对于 D 触发器而言，数据需要在时钟有效沿到来之后保持 Thold 时间。

考虑时钟延迟的影响：

考虑到电路时钟对于触发器时钟早到 1ns，所以电路有效保持时间 Thold_valid = Thold + 1ns = 3ns;

考虑路径延迟影响：

数据需要经过一段组合逻辑之后才能保持稳定，因此电路的有效保持时间为：

Thold_valid = Thold + 1ns - 2ns = 1ns。

***** 例题四： 系统的最高频率

下面这个题目和上面题目相差无几：
https://img-blog.csdnimg.cn/2019082412195279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYm9ybl9MZWU=,size_16,color_FFFFFF,t_70

首先要明确，系统的最高频率只和相邻触发器之间的电路有关（关键路径）

求电路的固有建立时间和保持时间和上一题的有效建立时间和保持时间是一个意思的。

因此固有建立时间为 Tsu_valid = Tsu - T_offset + Tpd + Tpd1 = 2 - 1.2 + 1.2 + 0.9 = 2.9ns

固有保持时间为：Th_valid = Th + T_offset - Tpd - Tpd1 = 1.5 + 1.2 - 1.2 - 0.9 = 0.6ns.

而系统的最高频率呢？

先求系统的最小周期，考虑两个触发器之间的路径：

Tmin = Tco + Tpd + Tsu = 1.8 + 1.2 + 2 = 5ns,那么系统最高频率为 200MHz。


***** 例题五：时间裕量
https://img-blog.csdnimg.cn/2019082412321713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYm9ybl9MZWU=,size_16,color_FFFFFF,t_70

这个题目让求 setup time margin，意思大概就是建立时间裕量，就是系统周期减去 Tco，Tgate 以及 Tsu 之后还可以有多少裕量，那，Tco，Tgate 以
及 Tsu 当然要用最大的来代入，因为要保证系统在最恶劣的情况下，能有多少裕量。

因此：

Tmargin = 10ns + 0.6ns - 0.2ns - 0.65ns - 0.35ns - 0.45ns = 8.95ns

其中 0.6ns - 0.2ns 表示的是时钟偏斜量，可见是时钟整偏斜，有利于时钟裕量。

-------------------------------------------------------------------------------------------------------------------------------

总结开来，最难的部分应该是求电路的固有建立时间和保持时间了吧，建立时间和保持时间是一对冤家，利你不利它，如果你分析了建立时间，那
么保持时间相反就可以了，例如逻辑门延迟不利于系统建立时间（+），那么不利于系统保持时间（-），时钟延迟有利于系统建立时间（-），则
不利于系统保持时间（+）。

可以当做偏方服用。

**** DONE 微软面试 100 题 2010 年版全部答案集锦
     CLOSED: [2020-10-05 Mon 09:49]
https://blog.csdn.net/v_july_v/article/details/6870251
*** DONE 笔试
    CLOSED: [2020-10-05 Mon 09:49]
**** 阿里一面
//评测题目: 无
你好


1.	FPGA 有哪些资源；？和其他处理平台相比，特点是什么？目前最新的器件发展趋势是什么？
	答：（1）FPGA 的资源可以分为三大类：一是计算逻辑单元，由 LUT、MUX、FF、进位链等组成。
    		二是 IO 资源。三是布线资源。
            在 FPGA 也可以集成 PLL，RAM，SOC 等，这些属于可选资源
       （2） CPU 是单指令单数据，GPU 是多数据单指令，FPGA 是多数据多指令
       		和 CPU 平台相比，FPGA 的特点是并行化，可编程硬件，同步时序方式处理而非顺序处理。
       		和 GPU 平台相比，FPGA 的特点是硬件可编程。
            和 ASIC，CPLD 平台相比，FPGA 具有更多的时序资源，但有较少的逻辑资源，
            同时其逻辑单元的实现基于查找表。
        （3）发展趋势：在 FPGA 硬件实现的方向，低功耗，高稳定性，高集成化，3D FPGA 模型，优化建立保持时间。
        	在应用方向，高处理速率，与 HIP 或硬宏集成，提高数据运算能力。
            在开发方面，优化布局布线。


2.	关于跨时钟域下面说法正确的是（2）： （和面试官沟通是多选题吗？）
1 异步时钟之间无法做时序约束，所以跨时钟域的路径要设置 false path 约束
2 跨时钟域常用方法是用异步 fifo
3 寄存器的异步复位 pin 由于是异步的，所以不需要做时序分析（释放的时候）
4 异步信号通过一级寄存器同步化后可降低产生亚稳态的概率


4.	编程：检测 1101110 序列
	module detector(input bit_in, input clk, input rst_n, output reg ret);
		parameter state_idle = 8'b00000001;
        parameter state_1 = 8'b00000010;
        parameter state_2 = 8'b00000100;
        parameter state_3 = 8'b00001000;
        parameter state_4 = 8'b00010000;
        parameter state_5 = 8'b00100000;
        parameter state_6 = 8'b01000000;
        parameter state_7 = 8'b10000000;

        reg [7:0] cur_state;
		reg [7:0] next_state;
		always @(posedge clk or negedge rst_n) begin
        	if(!rst_n) begin
            	cur_state <= state_idle;
            end else begin
            	cur_state <= next_state;
            end
        end

        always @ (*) begin
        	case(cur_state)
              state_idle: if(bit_in == 1'b1) next_state = state_2;
                          else next_state = state_1;
              state_1: if(bit_in == 1'b1) next_state = state_2;
                       	  else next_state = state_1;
              state_2: if(bit_in == 1'b1) next_state = state_3;
                       	  else next_state = state_1;
              state_3: if(bit_in == 1'b0) next_state = state_4;
                       	  else next_state = state_3; // 检查一下
              state_4: if(bit_in == 1'b1) next_state = state_5;
                       	  else next_state = state_1;
              state_5: if(bit_in == 1'b1) next_state = state_6;
                       	  else next_state = state_1;
              state_6: if(bit_in == 1'b1) next_state = state_6;
                       	  else next_state = state_4; // 检查一下
              state_7: if(bit_in == 1'b0) next_state = state_1； // 有两种选择？
                       	  else next_state = state_3;  // 检查一下
              default: next_state = state_idle;
        end

        always @ (posedge clk or negedge rst_n) begin
        	if(!rst_n) begin
            	ret <= 1'b0;
            end else begin
            	if(next_state == state_7 && bit_in == 1'b1)
                   ret <= 1'b1;
              	else
                   ret <= 1'b0;
            end
        end
    endmodule


5.	编程：用 verilog 实现一个异步 FIFO，带 full/empty 以及 almost full/empty
	module( input clk1, input clk2, input read, input read, input reg [D:0] data_in, output reg [D:0] data_out);

      	// 异步信号同步释放
        reg read_reg1;
        reg read_reg2;
        always @ (posedge clk1) begin
        	read_reg1 <= read;
            read_reg2 <= read_reg1;
      	end

        reg write_reg1;
        reg write_reg2;
        always @ (posedge clk2) begin
        	write_reg1 <= write;
            write_reg2 <= write_reg1;
      	end

        // 更新读地址和写地址
        reg [N:0] wr_addr;
    	reg [M:0] rd_addr;
        always @ (posedge clk1) begin
        	if(read_reg2) begin
                   rd_addr <= rd_addr + 1;
                   data_out <= fifo[rd_addr];
            end else begin
                   rd_addr <= rd_addr;
                   data_out <= 0;
          	end
        end

        always @ (posedge clk2) begin
        	if(write_reg2) begin
                   wr_addr <= wr_addr + 1;
                   fifo[wr_addr] <= data_in;
            end else begin
                   wr_addr <= wr_addr;
            end
        end

        // 判断满
        reg full;
        always @ (posedge clk2) begin
        	if(write_reg2) begin
        		if(wr_addr + 1 == rd_addr) begin
                	full <= 1'b1;
                end else begin
                	if(wr_addr == rd_add) begin
                    	full <= full;
                    end else begin
                    	full <= 1'b0;
                   end
                end
            end
        end

        // 判断空
        reg empty;
        always @ (posedge clk1)
    		if(read_reg2) begin
        		if(rd_addr + 1 == wr_addr) begin
                	empty <= 1'b1;
                end else begin
                	if(wr_addr == rd_add) begin
                    	empty <= empty;
                    end else begin
                    	empty <= 1'b0;
                   end
                end
            end
        end
    endmodule
*** [[file:./hardware.org::*FPGA][FPGA info]]
* Job Hunting
** Resume

https://github.com/chxin/resume
[[file:~/Documents/Resume/简历-程欣-华中科技大学.pdf]]
** Job Information
*** Huawei：云核心网：AI 平台/性能优化
**** 笔试

1. 题目描述
Sam 从小就对元音字母(a,e,i,o,u,A,E,,O,U)很感兴趣，他在写日记的时候都会
把元音字母写成大写的，辅音字母则都写成小写，为了避免妈妈偷看自己的日
记，他同时会把元音字母复写一遍;我们摘录一段 Sam 日 记的字符串 S(长度不超
过 100，只包含大小写的英文字母和空格)，请把它还原为可以正常阅读的字符
串(单词的首字母大写)。
你试试把 Sam 日记的一个句子翻译成正常句子吧。
输入描述:
输入一个字符串 s (长度不超过 100，只包含大小写的英文字母和空格)。
输出描述:
根据 Sam 写日记的习惯输出翻译后正常的字符串 S。
示例 1 输入输出示例仅供调试，后台判题数据一般不包含示例
输入      | 复制
wh00 100vEE sAAm
输出      | 复制
Who Love Sam

2. 题目描述
有一个英文字符串 str，其中包含多个单词，单词之间用单个空格分隔，一行最
多显示的字符数通过 maxLine 表示，其中 maxLine > 2 个字节;
1)如果该单词正好可以显示在该行，那么不需要连字符;
2)如果该单词无法在本行完整显示，那么需要连字符"一"分割，其中连字符放在
行尾，该单词的其他部分移到下一行; maxLine 比较小的情况，该单词可能显
示在多行，需要多个连字符;
3)如果该行尾正好是空格，那么不需要连字符;空格后的单词直接移到下一
行;
4)如果行尾正好是某个单词的第一个字符， 那么这个单词直接移到下一行显
示; (本行会少一个字符， 不需要添加额外的空格)
输入描述:
第一行为英文字符串;字符串包含结尾 NULL 最长 1000 字节;
第二行为行的最大宽度;
输出描述:
分割后的多行字符串，每行字符串包含在{}中;

3. 题目描述
集合的运算

**** 问题

1. MEC(mobile edge calculation)移动边缘计算，是和部门相关的业务吗？未来的发展方向是什么？
2. 5G 和物联网对现有的网络结构会产生较大影响吗？现有架构可以满足相关需求吗？
3. 会考虑替代 CPU 的硬件吗？

*** ByteDance: 硬件开发工程师
**** 提问

1. 硬件开发工程师的主要任务是什么？你们主要在解决什么问题？
2. 我理解的字节跳动是互联网大厂，有发展硬件的需求吗？如果需求完成，硬件开发是否就是要淘汰掉？
3. 硬件开发对软件、语言、和算法的要求是什么？需要补相关的知识吗？
4. AILab 的发展方向是什么？

*** 百度: 北京-AI 异构计算工程师
**** 工作职责

  - 我们致力于构建全球领先的 AI 异构计算加速引擎和加速平台。建立融合推理（Inference）、训练（Training）的软硬件一体的 AI 计算加速解决方案，并应用于行业最大的规模的 AI 数据中心，解决云计算、搜索、信息流、图像、视觉、语音、自然语言处理等的算法优化与计算加速问题
  - 负责大规模 AI 前向计算引擎（Inference Engine）框架和底层算子开发与优化
  - 负责大规模 AI 计算通信库及通信算法开发与优化
  - 负责面向 CPU/GPU/FPGA/ASIC 等多元化计算架构的编译系统开发、编译优化和算法加速
  - 负责异构高性能计算平台的设计、研发，高性能计算库、通信库开发与优化

**** 职责要求

1. 专业技能，具体要求如下
  - 热爱编程，精通 C++/Python
  - 具有独立开发能力，对 AI 算法和主流框架有丰富的应用或开发经验
  - 精通 GPU/ARM/MIPS/DSP 等任意异构计算平台
  - 精通计算机体系结构，有汇编级别开发经验
  - 精通 GPU/ARM/MIPS/DSP 等异构计算平台的通信库
  - 精通 MPI，对不同网络拓扑结构的通信算法及底层通信函数有深入研究，对 RDMA，GPU direct 等技术有了解
  - 对分布式计算有深入理解，特别是同步，异步等通信策略在 AI 计算中的应用
2. 软素质，具体要求如下
  - 目标驱动，并有探索精神
  - 团队协作及沟通能力
  - 具备分析和解决问题的能力
  - 有极强的学习能力和知识迁移能力
3. 具有以下条件者优先
  - 精通 PaddlePaddle、Caffe/Caffe2、MXNET、TensorFlow 等开源框架，做过源码级优化移植等工作
  - 熟练使用 Cublas、Cudnn、MIopen、OpenBlas、MKL、Eigen 等主流计算库
  - 熟悉 AI training 通信过程，熟悉 MPI，NCCL，RDMA，GPU Direct 等通信技术
  - 精通 CUDA/OpenCL 开发，有 SASS 或 PTX 级别优化开发经验
  - 精通 Neon 或 ARM-GPU 开发，有过大小端并行计算优化经验及 ARM-GPU 协同开发经验
  - 精通常用硬件平台性能分析工具链，如 CodeXL\NVVP\GPA 等
  - 精通 LLVM
  - 有 Linux 内核相关开发和优化经验
  - 熟练使用 Cublas、Cudnn、MIopen、OpenBlas、MKL、Eigen 等主流计算库
  - 熟悉 AI training 通信过程，熟悉 MPI，NCCL，RDMA，GPU Direct 等通信技术
  - 精通 CUDA/OpenCL 开发，有 SASS 或 PTX 级别优化开发经验
  - 精通 Neon 或 ARM-GPU 开发，有过大小端并行计算优化经验及 ARM-GPU 协同开发经验
  - 精通常用硬件平台性能分析工具链，如 CodeXL\NVVP\GPA 等
  - 精通 LLVM
  - 有 Linux 内核相关开发和优化经验

**** 提问

1. [ ] 我理解的异构计算要解决 *存储，网络和计算* 三大模块的事，请问您是怎么处理的？组内是否需要一个做网络和存储的人呢？
2. [ ] 请问您要解决的主要问题是什么？在后摩尔时代，面对膨胀的数据量，会对现在的架构造成什么冲击，改革是否势在必行？
3. [X] 您的异构是指“CPU+GPU”吗，考虑 ASIC 和 fpga 吗？
4. [X] 谷歌的 TPU，寒武纪的 AI 芯片，这些属于异构计算要解决的问题吗？
5. [ ] 百度的系统部和基础架构部，主要解决什么问题，两者有重叠的部分？

*** 中兴：FPGA 开发工程师
**** 主要职责
***** FPGA 开发

1. 参与产品研发，负责 FPGA 逻辑设计、仿真、软硬件接口联调、测试验证；
2. 负责相关算法的建模以及 FPGA 方案设计与实现。

***** 视频监控产品

1. 负责会议电视终端、MCU 等视音频设备的 FPGA 模块编写，仿真验证和维护；
2. 负责视频相关算法在 FPGA 上的实现；
3. 与软硬件联调开发并解决测试故障。

**** 任职要求
***** FPGA 开发

1. 具备数字电路专业知识技能；
2. 有良好数学功底，熟悉 Verilog/VHDL/SystemVerilog 任一编程语言，有 Python/C/C++编程经验者优先；熟悉 FPGA 基本架构,了解 CPU/GPU/DSP 等基本架构；
3. 具备优秀的英语读写能力；
4. 有算法设计、建模、优化，数字信号处理，AI 算法(人脸识别、物体识别)，高速接口设计等项目经验者优先；
5. 熟悉 FPGA 原理、开发流程、调试手段，从事过 Xilinx 或 Intel、Altera FPGA 项目应用经验者优先；
6. 有通信行业设计开发经验者优先。

***** 视频监控产品

1. 精通 Verilog/VHDL 语言，具有较强的编码能力，熟练运用 Quartus、Vivado、Modelsim 等 EDA 软件；
2. 熟悉 FPGA 的开发流程，能够独立完成 FPGA 模块设计与仿真，对 Altera、Xilinx 等主流 FPGA 开发有丰富经验；
3. 熟悉约束编写、时序分析及优化；
4. 了解 FPGA 相关硬件，具备基本硬件知识；
5. 熟悉视音频规范以及接口，如 HDMI,PCIE,RapidIO,DDR,I2S、SERDES 等。有用 FPGA 进行视音频设备开发的经验。

**** 蓝剑计划

中兴于 2014 年提出。
- 蓝剑计划是中兴通讯未来领袖计划，是一个更宽广的平台，在这里有全球化的工作机会及视野，开拓创新的机会。
- 蓝剑计划是公司最核心的人才战略，为公司培养了 *最尖端的人才* ，是公司在 *ICT 领域持续保持竞争力* 的坚实壁垒。我们急需一批在 *技术上有“杀手锏”* ，有激情、有活力、更具 *创新精神* 的新时代力量的加入。
- 聪明自信，学习能力强的优秀毕业生。在工作上，坚定、有韧性，能从挫败中快速恢复，成就动机强，致力于达成更高的目标；在行动上，享受拼搏，积极主动，愿意比他人付出更多；在协作上，高情商，善于沟通协作，处理好各种人际关系。
- 顶级导师配备：“三导师”的豪华导师团，从日常工作、专业方向、职业发展三维度对蓝剑进行指导
- 系统培养机制：蓝剑培养期为三年，并设置“闯关制”即每年给蓝剑制定挑战性任务以给予蓝剑成员充分的动力和压力。
- 加速晋升通道：
- 特殊的薪酬待遇：高于业界的特殊薪酬待遇，专项的蓝剑津贴，奖金承诺+股权激励

***** 我的疑惑

培养计划：轮岗？还是技术突破？还是管理？还是主导重大科研项目？一夜成名，对于员工是否压力过大，对老员工是否不公平
福利：加班情况，房子，户口。高薪资，是每个月的工资就是总数/12，还是，大部分要作为考核的奖励才有。
前景：现在通信行业已经进入平稳期了，中兴下一步的发展是什么？

***** 觉得有什么样的能力水平才能配得上蓝剑

看到这样一个很特殊的招聘，我脑海中浮现的第一个形象，就是韩信：萧何月下追韩信之后，直接官拜大将军，之后披坚执锐，用兵灵活，无往不胜。我觉得，蓝剑计划需要的是能够攻坚克难，实现技术突破，打破技术壁垒的人。

说到能力，我觉得，在工作上，一定要有韧性，不怕困难。在行动上，要果断，积极，有创新意识，逻辑思维能力强。尤其是在合作上，一定要成熟的工作方法，带活一个团队。

*** 阿里：阿里云基础架构工程师
** DONE Interview Skills
   CLOSED: [2020-10-05 Mon 09:50]
*** 面试的时候问项目

问一些和项目相关的问题，其实这就是为了确认项目是不是你做的

*** DONE 面试技巧
    CLOSED: [2020-10-05 Mon 09:40]
**** 自我介绍
   为什么这份工作非要你来做才适合！如果你能列举 4 点以上的“相似”，那么这份工作对你来说已经胜利在望了。
**** 对公司了解
   1. 概况：公司的地位、总部、规模等
   2. 表达为什么你非得选择我们公司？：公司的实力、发展一致、平台
**** 不同公司的比较
强调现在是你最想要稳定的时期
**** 优缺点
什么是重要的素质？性格方面的问题，人际方面的问题，工作能力方面。这些缺点不要涉及
缺点不要求真实，不虚伪即可。缺点就是路痴
**** 提问
你有多想留在这个公司？来这里工作的强烈欲望

我对生活和工作有了一点了解，但培养计划？导师制是怎样的？技术情怀，热情
对我的要求是什么？您的团队氛围是什么的，团队内部以及部门合作是如何开展的？
培养和闯关，两者是否是挺冲突的
**** 不同人面试的维度
1. HR
   - 基本素质
   - 应聘动机
   - 思维能力
   - 薪酬期望
2. 业务面试
   - 思维能力
   - 业务能力
   - 经历经验
3. 高层面试
   - 基本素质
   - 思维能力
   - 业务能力

*** 牛客网处理输入输出

https://blog.csdn.net/qq_29996285/article/details/84937561

*** 分析问题的步骤

1. 寻找复杂问题的子问题
2. 寻找子问题的规律： 先从最简单的情况分析，下一步如果能利用上一步的结果（递归），下一步比上一步更复杂且无关系，就需要总结规律（循环）

*** 和面试官讲解自己的步骤

    在每次发言之前，就想好 *要说几个方面的事情* ，提前说出来。
1. 在问清楚了问题是什么之后，再讲解思路
2. 逐步递进：可以使用 xxx 吗，在这道题使用 xxx 对应了步骤 xxx
3. 确认边界条件
4. 优化：根据时间复杂度和空间复杂度的限制，写下算法步骤，并通过举例或图解释

*** 写代码时需要避免的问题

1. 不要忘输出的要求
2. 选择合理的数据结构（数据导入，数据取值）
3. 分析问题时要彻底
4. 卡壳的思路和正确有效的思路只差一点点，要小心求证，大胆尝试

*** 为什么从硬件转到 fpga

  这个问题可能是在问自己是否做好准备投入到 fpga，那么以下回答不合格。

  应该回复的是自己通过硬件学到了什么，然后 FPGA 在这个基础上做的更好，更适合自己。
  1. 硬件需要经验，不需要逻辑
     硬件每一次积累经验，都是经济损失。硬件一旦出错，就只能重做，不能模拟，这是巨大的经济损失。
     为什么硬件需要经验：现在的硬件开发，从选择器件到制作 PCB，都是自己设计的，解决这些别人早已解决的问题，我认为就是积累经验，犯过错误积累了经验，这次设计失误率就低一些，成本低一些。但这种经验是无法传授的，没有工具可以使用。
     硬件大量抄电路，初期自己设计所以出错。
     但是人积累了经验，年龄增长，逻辑就不如年轻的时候了。这是一种矛盾。
  2. 硬件没有社区，生态不完善
  3. 硬件没有库，需要重复造轮子
  4. FPGA 还有很大的潜力，现在 stratix 10 用到 14nm 的工艺

*** 听懂面试官的问题，找到他的关注点

1. 在中兴的提前批面试中，我要求在自我介绍的时候，着重讲自己的优缺点和获奖情况，我一个没有讲到。之后面试官有再次提问，我的获奖情况是什么？
   所以：
   - 面试官提到的关注点一定要有，如果“优缺点”这样不好问答的问题，可以选择性跳过。但最好是自己能够提前准备好这些问题回答。
   - 获奖情况需要加入到自我介绍中

**** 面试官认为的重点，你没有关注到，怎么回答？
*** DONE 优缺点
    CLOSED: [2020-08-06 Thu 10:54]

我一直认为：人的高度，是由思维方式决定的；人的深度，是由素养决定的

我是一个敏感简单又有执行力但认识浅薄的人。 （优点太特殊，缺点太致命了）

**** 最大的优缺点

不安分，喜欢一切新的东西，喜欢尝试；也造成了我对每一个领域都认识不够深刻

**** 缺点

目前就先选 2

1. 表面平静，内心暴躁
2. 容易激动，容易亢奋

**** 优点

目前就先选 1

1. 能坚持，不轻言放弃，能够承担一定压力
2. 心理状态好，积极乐观，自我恢复能力强
3. 团队协作能力强，理解能力强，沟通能力一般
4. 知识面广，设计硬件，软件，AI，网络
5. 逻辑思维能力强，我总觉得别人讲话的逻辑不是闭环的，跳跃性的
6. 洞察能力强，质疑习以为常的现象

*** DONE 团队合作
    CLOSED: [2020-08-06 Thu 10:54]

1. 分工明确
   合理、明确的分工，才能确保伙伴成为每一领域的精英
2. 团队氛围
   团队氛围是高效率工作的保证：有目标，有进步。
   举例：在西门子比赛时，状态好的时候就攻坚克难，状态差的时候就按照步骤进行；及时奖励自己
3. 文档与交流
   这里的 *文档* 并不是工作日志，而是有价值的结论及其完备的逻辑过程，方便别人能够短时间能参考了解你的工作。
   定期的交流，才能集思广益
4. PPT 与演讲能力
   所有的团队问题都是沟通问题。清晰地表达自己的意见；理解别人的意见；以减少沟通成本为出发点

*** DONE 自动化 vs 人工智能
    CLOSED: [2020-08-18 Tue 09:37]
人工智能属于自动化体系中的控制器的一部分。
**** 自动化体系
自动化体系中共有 4 个模块：控制器，执行器，检测器，反馈器。
每个模块都可以建模，最后整体用传递函数描述（s域）。
通过伯特图和奈奎斯特图来判断系统整体的稳定性（幅频响应和相频响应）。
**** 控制理论
控制理论，是有数学基础的，所有的结论，都是通过解微分方程等方式得到的。
但人工智能的理论，是不能证明的。
**** 控制器
传统的自控是 PID，现在的更通用的是人工智能。
*** 职业规划与人生理想

职业：探索 FPGA 在现在领域中的作用，FPGA 的极限在哪里（软件思维还是硬件），现在计算能力的瓶颈
理想：改变现有的以 CPU 为核心的计算架构

*** FPGA 应用

1. ASIC 原型设计
2. 网络安全
3. 数据中心加速
4. 有线
5. 雷达
6. OTN/数据中心互联

*** 软件和硬件差异性的一些思考
**** 数据结构

由于硬件使用的芯片内存较少，实现复杂的数据结构，比如树和图，除了其占用的复杂空间，其功能实现，也是巨大的资源耗费。
这部分工作，其实是人工代替了的，在连续的空间上，人来直接进行寻址。

硬件也有自己的数据结构，比如 CAM（内容地址寄存器）

**** 计算机体系结构

我学习的 8086，关于虚拟内存、并发、IO 总线、存储器层次，这些都是没有的。
在低性能的芯片上实现这些，根本享受不到这些技术的红利，反而会让简单直接的控制，一个 cycle 一个 cycle 的硬件工作方式，变成一条指令一条指令的软件控制方式。

**** 驱动

我们假设硬件都是有一个控制芯片的，负责和硬件所有的引脚相连，同时提供和 CPU 交互的 IO 总线。

硬件的驱动就是在芯片和硬件端，主要负责代码如何实现成硬件的动作，并把能够实现的最小的动作，封装并向上提供 API。更关注于动作。
软件的驱动就是在芯片和 CPU 端，主要负责通过 IO 总线，以命令的方式，调用一个动作，或组合动作实现复杂的逻辑。更关注于功能。

当然，也有硬件，既提供 API，又调用 API，这样就是一个系统，而不是纯硬件的问题。
我会在实现的时候把两部分完全分开来做。这也是我既做硬件也做软件，在认识和实现上的优势。

**** 对 “硬件这么落后” 的回答

硬件不是落后，而是为了性能和成本，做了很多的取舍。以一种直接、简单、高效的方式工作。

硬件这么落后，也不是没有原因的，生态太差，技术垄断。导致硬件工程师的素养差别巨大。

在后摩尔时代，硬件不能享受了制造工艺带来的红利，必然要走上 *新架构* 的路。
但根据我对 NVMe，CUDA 等高性能器件的认识来看，软件和硬件必须要融合，单纯在软件或系统层面做更多的优化，硬件的速度提不起来，还是有很大的限制，当硬件的速度提起来，在某些应用场合，软件的优化是可以减少的；
或者，是硬件工程师能够软件的思维和硬件的工作原理，来写出更高效的驱动程序。对于习惯于使用 API 的 CS guys，这不是他们的理解问题的方式。

*** DONE 优秀招聘的计划
    CLOSED: [2020-08-29 Sat 10:36]
我对职业发展生涯的理解：
  - 执行者
  - 设计者
  - 推动者
  - 突破者

但在优秀招聘方面，可能是两种方向
  1. 开疆扩土的将军
     带领团队，（带兵多多益善），攻坚破难
  2. 认识和能力金字塔的工匠
     曲高和寡，自己在某一个领域的认识越来越深刻，能够交流合作的人就越来越少，这是个金字塔般的发展；
     其价值就是，做好了可以成为指引未来发展方向

以上 2 种方向，看起来优招对 2 没有助力，因为一个高薪资高职位，只会帮助更加全面了解项目全貌，更加有助于带团队，但对于技术发展，这样广泛但不精通，把时间花费在团队上似乎是不利于技术提升的。

但是，只有成为了项目中重要的人，才能摆脱了工具人的身份，在关键技术和决策上有话语权，有自己能够选择去做什么，才真正可以去钻研。

*** DONE FPGA 的未来发展
    CLOSED: [2020-08-29 Sat 11:29]
FPGA 在人工智能时代的独特优势 Doug Burger 博士 https://mp.weixin.qq.com/s?__biz=MzU5MTgwNjIyMg==&mid=2247484125&idx=1&sn=cff2e11e937d7ffb38413345a6eebe86&chksm=fe2828bcc95fa1aad134950a3ef5ac2de56fd8532e3080308cb5d097c761fbab60fbb0917322&scene=21#wechat_redirect

赛灵思新一代计算平台 ACAP  https://mp.weixin.qq.com/s?__biz=MzU5MTgwNjIyMg==&mid=2247484169&idx=1&sn=2126849ca8fd9d5d8f06ad23e4849bb3&chksm=fe282968c95fa07edbda00b035176385feb5687dcd2f81d6726c9bd2c9a85cc0e79a41c6b514&scene=21#wechat_redirect

Catapult 微软 https://mp.weixin.qq.com/s?__biz=MzU5MTgwNjIyMg==&mid=2247484202&idx=1&sn=c45dc8d6c3dcb78dad069f76359cb1ce&chksm=fe28294bc95fa05d232ecf842254800cc53a77aed937e4f7f5d446cbeb5daeebcaca3422cd98&scene=21#wechat_redirect
**** ISFPGA 介绍
决定着 FPGA 技术发展的新成就，都会集中发表在一年一度的“FPGA 国际研讨会”上（简称 ISFPGA）。从 1993 年举办至今，ISFPGA 一直是 FPGA 领域的旗舰级顶会，没有之一。在 ISFPGA 上发表的文章，都代表着 FPGA 最前沿和最优秀的研究成果，也被业界人士看成是预测 FPGA 今后发展方向的风向标。

从整体上看，业界的研究方向主要集中在两个方面：

1. 和人工智能和机器学习相关的各个领域，比如 FPGA 微架构、FPGA 编程工具与编程语言，以及 FPGA 在 AI 的各种应用等。
2. FPGA 的高层次综合（High-Level Synthesis，HLS），也就是使用高层语言，如 C++/OpenCL/Python 等，对 FPGA 进行有效的编程和使用。

***** FPGA 微架构：低精度乘加单元
随着软硬件技术的不断发展，DNN 算力的瓶颈已逐渐从 *内存带宽* 转向乘加（MAC）操作效率，取而代之的是单周期可以完成的乘加操作数量，因此本文提出了面向英特尔 FPGA 的全新低精度乘加单元微架构。是针对 DNN 应用的“杀手级”微架构创新。提出的新架构专为英特尔 FPGA 设计，预计会带来巨大的竞争优势。

实现这种低精度的 DNN 数据通路，FPGA 往往是超越 CPU 和 GPU 的第一选择，因为它在灵活性和性能等方面有着很好的平衡。

微软的脑波项目就使用了自定义的低精度（8~9 位）浮点数表示。

传统的 FPGA 架构在执行乘加操作时，会浪费大量逻辑资源，进而导致性能无法达到最优。提升 DNN 里乘加操作的性能和资源使用率。
一种方法是在传统 ALM 结构里增加一条额外的进位链，如下图所示。这样避免了使用多余的 ALM 完成最后一级加法操作，从而节省了逻辑资源，也减少了 ALM 间的传输延时。
使用这种方法，乘加操作的平均延时会缩短 21%，乘加单元的面积会减小 35%。
***** 名为 HetroCL 的可重构计算编程语言框架
基于 Python 的 FPGA 编程模型与编译工具，为 DNN 应用而优化。

降低了 FPGA 的编程难度，有效解决了一些当前高层次综合存在的问题与痛点。相比传统的 FPGA 开发与编程模型，这个新提出的名为 HetroCL 的领域专用语言和编程框架兼顾了性能与开发效率，使开发者可以专注于算法实现，而无需考虑 FPGA 底层逻辑的实现与优化。

FPGA 的高层次综合（High-Level Synthesis）指的是将诸如 C++、OpenCL 等高层语言，通过特定编译工具直接转化成 FPGA 上可以运行的硬件代码。

虽然算法和模型可以使用高层语言编写，但为了达到最优的硬件性能，开发者仍然需要清楚的了解底层 FPGA 的硬件架构，并通过特殊的预处理指令指导 HLS 编译器生成期望的硬件结构。这也使得 HLS 在很多时候并没有体现出它的便利性优势。

一种基于 Python 的领域专用语言（Domain Specific Language），名为 HeteroCL。它的最主要特点是能将算法描述与底层硬件结构进行完全解耦，使得算法设计师不需要关心底层硬件的数据类型、计算单元实现以及存储器架构优化等
***** 使用 P4 语言编程 FPGA
使用高层语言“P4”构建网络算法和应用，并直接映射到 FPGA 上执行。

这是一种快速开发 FPGA 的新方法。与基于 RTL 的传统 FPGA 开发方法、以及基于 C/C++的高层次综合 HLS 相比，这种方法在性能和灵活性达到了很好的平衡。P4 适用于诸如网络数据包处理等算法和应用，使用者不需要掌握 Verilog 或 VHDL 等硬件描述语言，就可以快速完成网络算法的建模与 FPGA 硬件实现。

使用 P4 编写计算机网络算法，并如何通过新提出的软件工具将其自动映射到 FPGA 上

P4 是一种领域专用语言，主要被设计用来描述各类网络算法与应用，如数据包处理、分类、查找、路由等等。顾名思义，P4 语言的主要设计目标有以下三点：

协议无关：即 P4 语言及其底层硬件可以支持各类网络协议
现场可编程：即部署后仍然具有可编程能力
可扩展：即 P4 可以在多种硬件平台上使用

FPGA 有着很好的灵活性，能够实现多种网络算法并在其中灵活切换，因此被广泛用于网络数据处理的场合，例如之前讲过的智能网卡等等。

将 P4 程序，借助赛灵思的 P4 和 SDNet 编译器生成底层的 Verilog 模块，然后映射到名为“NetFPGA”的参考设计上。

在生成 Verilog 模块的过程中，使用了定义好的模块库和元组。因此这种方法本质上是一种 FPGA 虚拟化方法，即在 FPGA 底层硬件之上，增加了一层虚拟的模块层，并可以通过 P4 语言直接映射。
***** 将 DNN 模型映射到 FPGA 云的开源架构
用于将训练完成的 CNN 模型映射到亚马逊 AWS FPGA 云服务上运行。

这篇论文与微软脑波项目完成的目标非常类似，只是实现方法有所不同。老石之前介绍过，脑波项目将训练好的 DNN 模型转化成数据流图表示，然后根据单一 FPGA 的资源情况，对数据流图进行拆分，并映射到 FPGA 的软核 NPU 上。

在这篇论文中，直接使用 HLS 工具对 DNN 模型进行综合，见下图，这在很大程度上减少了开发的难度，但与脑波方案相比，不可避免的会有较大的性能差距。同时，这个工作只支持 Caffe，而不支持其他 DNN 框架。

在脑波项目中，FPGA 基础架构是源于 Catapult 项目的大规模 FPGA 互联和资源池，而本论文主要面向的是亚马逊 AWS-F1 实例的 FPGA 公有云。这样的好处是能为广大 AWS 开发者或其他希望进行 FPGA DNN 加速的用户提供参考平台和经验借鉴，但同样的也会有明显的性能限制。

相比 CPU 而言，使用 FPGA 对 DNN 进行硬件加速仍然可以取得可观的性能提升。比如在这篇论文中，针对不同的 DNN 模型，使用 FPGA 可以取得 47 倍~104 倍的加速性能。
***** 多线程代码的高层次综合工具：EASY
使用形式化（formal）方法，有效减少高层次综合多线程代码时使用的内存仲裁器数量与逻辑复杂度。
极大的提高了 FPGA 的高层次综合工具的性能，尤其是对多线程代码有了更好的支持。

当对多线程代码进行 FPGA 的高层次综合时，多个线程之间对内存的读写需要额外的仲裁机制，这主要用来判断某块内存会被哪些线程所访问。而这个仲裁机制在硬件实现上会有很大的额外开销，对性能也有很大的消极影响

不过，线程往往不会访问所有内存块，因此很多情况下仲裁器不需要支持全部的线程-内存块映射，这样就大大减少了仲裁器的逻辑复杂度，从而提高了系统性能。

为了判断某个线程是否会访问某个内存块，作者使用了形式化方法，通过将多线程代码转换成一种单线程的形式化描述语言 Boogie，并通过形式化工具证明某个线程与内存块的访问关系，这样就能完全确定仲裁器需要支持的线程与内存块的映射。

这个思路十分简洁但有效，它的完整流程图如下图所示。这篇文章使用这种方法取得了高达 39%的性能提升，以及高达 87%的面积缩减。
**** FPGA 开发
- SV 更加完善，开发更加高效，代码阅读更方便
- ip 更丰富
- 验证工具 更完善
**** 制造
功耗，工艺
**** 应用场景
这正是我的短期目标，挖掘 FPGA 在网络、AI 的用途。

** 中兴蓝剑面试准备
*** 面试问题
**** 自我介绍
     先按照之前的自我介绍。
     但是有没有必要突出自己项目之外的能力，比如学习、合作。
***** 学会做事
      认识问题，解决方案的辨析，逻辑自洽，可行性分析，实践，把过程总结为方法
***** 学会思考与交流
      微软导师告诉我，可以用两月时间做设计，最后一个月把设计串起来；也一直写代码优化;
      做成与做好，极高标准，交流红利（有思路时 vs 没思路时），短时间内表达想法；
**** 项目的意义
 - AIPre：数据传输绕过 CPU，解决数据中心的速度瓶颈问题，使得器件之间可以直接通信
 - 光纤：在强电磁机械干扰条件下的高精度测量；在项目即将无法交付时提出解决方案
 - SLD：飞机安全，适航需求

**** 项目里你担任的角色，项目里其他人的角色 可以多谈 SLD
 - AIPre：组员； 其他还有实习生负责不同的模块，工作没有交集或者在导师的指导下互相交流；我的导师和部门领导，负责汇报和讨论方案
 - 光纤：组员； 还有一个负责数据处理，我负责传感器的仿真设计，我们两个互相配合
 - SLD：负责人； 与商飞协商技术协议（条款解释，性能参数），和组员完成设计方案， *带领代码和实验* 。我自己选择一部分不可绕过的核心任务，其他人负责其他任务，做完之后 *code review* ，搭建实验平台，共同交换实验报告。
 - 西门子竞赛： 组长； 一个组员负责调试设备，一个组员负责整理数据并修改参数，组长负责方向和进度以及文档
**** 如何带领大家
 1. 对项目有完整的清晰认识，合理的分工，只有这样组员才有可能深入钻研，成为一个领域的专家，不依赖于组长。
 2. 弱化带领形象
    我负责项目整体的方案，我也会直接加入到项目的设计和实现中，只不过我会选择一部分不可绕过的最核心的任务来做，这样我的工作就会和其它人的工作有交集。
    我也是和其它人一样的学生身份，我不会颐指气使地分配任务，我也要做一部分工作而不是其他人都做事我把他们的结果拿过来当作我自己的，但是最后的分工一定要明确。
 3. 强化领头意识，强化服务意识
    不是因为我是项目负责人，让大家信服我，而是我确实可以帮他们推动项目的进展， *可以提出建设性的意见，以此来形成领头意识* 。
**** 项目中遇到过什么分歧，如何解决？
 讲不出来的，无理取闹的，不和逻辑的分歧没有遇到过，即使遇到我也会选择回避。我觉得你的想法太好了，可以直接和我的导师谈一下。
 1. 在实验室和微软实习
    在实验室因为大家都允许犯错，甚至开脑洞挑战不同的方向，是很开心的事，要记录下来并尝试不同的方向。但一定要找到最成熟实际的方式来解决问题，但一定是要约定在完成了实验室的基本任务之后，再向老师申请时间来处理分歧。
    你没有创新，也没有发现问题，我很抱歉。

    在微软实习期间，我们就是要找到问题的最优解，只要做到 *逻辑自洽* ，能够跟别人讲明白，基本大部分的分歧都可以通过和导师讨论，做最后的决定。这种分歧更多是自己的思考。

 2. 在西门子竞赛:找到原因，承担责任
    遇到了巨大的分歧，最直接的表现是，要控制稳定还是最高产出？一个更稳，一个抓住了比赛的需求更加冒险。
    根据我们当时的所有的信息（评价指标无法确定，系统参数的变化可能使系统不稳定），我们无法推断出哪一个方案更好，都认为对方有道理，但不愿放弃自己的坚持。
    最后，我说，比赛想拿一等奖吗？
    其实我们在争论的最后，我们都非常清楚，如果改了方案，最后的成绩不好怎么办？我们并不是真的讨论方案的好坏，我们都小心翼翼绕过了这个敏感点。
    我觉得我作为队长，有必要把这个问题直接提出了，并把责任承担下来。

**** 假如有个人就是不做，你该怎么办？
 不存在就是不做的人，只会有不知道怎么做事的人；
 有希望，有利益，认同，才会有动力；
 如果故意不配合，查找自己的处理人际关系的问题，及时踢出该成员。
**** 导师对你们的项目如何指导？
 随时讨论，定时组会
 1. SLD
    在组内，我们只讨论怎么做。

    具体方案到我这里就结束了，我努力做好一个项目的推动者，向导师汇报，我尽量做到详细和逻辑闭环：需求是什么，我们怎么做的，结果是什么，中间经过了哪些改动。导师就可以把控一些更高层面的设计方案。
    甚至我还想在汇报的时候，尽可能把重要节点都记录下来，导师可以在需要的时候，查看我们做了什么，没做什么。
 2. 光纤燃油
    我接手这个项目的时候，已经面临交付了。
    我和导师讨论方案的可行性，他给了我最大的支持，重新建模仿真光纤。
**** DONE 你对中兴怎么看？学长学姐怎么和你说中兴。
     CLOSED: [2020-10-05 Mon 09:40]
 1. 工程师
    不像互联网企业，中兴真正在做工程，在解决通信领域的问题，为通信行业提供解决方案
 2. 中兴的 5G 技术
    专利，技术，市场占有，都非常有优势
**** 为什么想来中兴？
 1. 短期工作计划
    中兴无线 FPGA 团队
 2. 5G 技术
    中兴在 5G 方面的专利，在市场的占有，这都表明了中兴的实力。中兴目前没有美国的封锁，这是机会
 3. 蓝剑计划
    平台和培养方案

**** 与通信系的学生相比你觉得你的优势在哪里？
 1. 通信，算法与硬件
    通信系的学生，比我在通信知识和通信算法上有优势，但中兴的无线部门，5G 的实现是个当前主要问题，是在硬件上实现通信算法，这更多的是硬件算法，更考验的是工程能力
 2. 对硬件的理解，对 FPGA 的情怀
    我从 PCB 转到 FPGA，我基本了解这些设计过程，我坚持 FPGA。
    我在微软实习的时候，我们经常从高层次来讨论某种实现是否足够优秀，我积累了部分硬件的理解

**** 薪资
***** 薪资

谈薪资之前要谈清楚所有考虑之后，再决定。
谈薪资的能力，是否也是考察的一个步骤呢？能谈出高薪的能力？

1. 最高薪资我不期望：我知道和国内最顶尖的一批学生，是有差距的，在微软实习期间，我的专业素养是不如他们的（项目，实验室，工作(陈海波）)，但我和平台高的学生做到了几乎一样的产出，就证明了我的能力
2. 我也有自己的长处：
   - 精力好，适应能力强，抗压能力强，执行力强，思维逻辑强
   - 在实验室从零做起，没有特别深入的研究，没有特别容易出成果的项目，但参与了每一次的进步，博士博后高工
   - 创造了很多第一次：国奖，研一 SCI，互联网大厂实习，独立带项目。
3. 50～60 万
***** 考虑
 60 万/年
 1. 我的优势和不足
    不足：硕士，非重点实验室

    优势：1年完成了博士毕业标准（1个项目+2 篇论文），并微软实习。这份履历证明了我的工作能力，招我等于招了博士
 2. 40 万/年
    没有太多的吸引力，和互联网大厂直接需要做权衡

    我需要经常和别人解释，为什么不去百度去中兴

 3. 薪资与压力
    40 的话，末流，我会觉得很随意，甚至感觉不受重视，工作没有激情。

    更多薪资，主观，给我的压力就是逐步递增的。
    我在压力下的产出，相比根据我硕士第一年的经历可以判断出来。
    60 绝对在我可承受范围之内，并能激发工作激情。

    给我最高的薪资，我其实也要考虑一下能否接得住。
**** 提问
 1. 中兴蓝剑的培养计划
    - 每年考核：没有选定项目，怎么考核？（解决的问题，业绩）
    - 考核失败：
    - 管理和技术路线的区别：职位的提升对技术的帮助是什么？
 2. 中兴如何应对美国的封锁和限制
    - 无线硬件，对 FPGA 和芯片制造的依赖很高
    - 国产替代，无线产品的竞争力下降
 3. 5G 以后的发展，这个就不问了
    - 5G 和 6G 是否伪需求
*** 蓝剑答疑
    1. 关于蓝剑“是什么”的疑问
       蓝剑计划的培养目标是什么？为什么中兴会在 2013 年出现这样的计划？为什么中兴蓝剑计划在网络上的相关信息很少？
    2. 关于蓝剑培养机制的疑问
       可以从 3 年的蓝剑培养学到什么？每年闯关的形式会有很大压力吗？考核的形式和要求是什么？有没通过考核的案例吗？
    3. 关于蓝剑现状的疑问
       部门的蓝剑在负责什么项目或业务？部门对蓝剑的要求是什么？部门已有的项目和未来发展方向是什么？假设一个普通员工很努力，能做到和您现在一样的程度吗？
    4. 关于蓝剑定位的疑问
       在工作生活中，蓝剑是很尴尬的人群吗？（我是指：对蓝剑的期望与实际产出可能不一致）
       蓝剑对于职业发展的影响是什么，其中是否也会有不利影响？
** Self introduction
 在工作上，坚定、有韧性，能从挫败中快速恢复，成就动机强，致力于达成更高的目标；
 在行动上，享受拼搏，积极主动， *愿意比他人付出更多* ；
 在协作上，高情商，善于沟通协作，处理好各种人际关系。
*** 按部就班的本科

本科偏向于硬件和自动控制
1. 课设： 由软件到硬件，打下 EE 的基础
2. 比赛： 大三暑假，西门子杯过程控制大赛，得了华中赛区一等奖
3. 实习： 大四，校外实习（施耐德电气开发实习生），校内实习（大三进入实验室）

从我的本科项目可以看出，本科的主要方向是电气工程

*** 寻找自我价值的研究生

1. 光纤燃油液位传感器： 最佳的斜刨角度是什么？
  在飞机油箱这种高电磁干扰、机械抖动的环境中进行高精度的燃油液位测量。
  传感器性能远超同类传感器。
2. JPEG 解码： 最大的 throughtput
  从 ssd 中读取一个 jpeg 文件的字节流，在 FPGA 上将 jpeg 文件转为 RGB 颜色信号，并缩放到合适的尺寸，送到 GPU 中。
3. 微软实习： 除了项目技能，更多的思维的改变
  收获：如何思考问题，表达自己的想法，与别人灵感碰撞
4. SLD: 不同的身份，会有不同的技能要求，对技能也会有不同的看法
   - 整理实验数据的重要性
   - 优秀可维护代码的重要性
   - 工作计划和合理分工的重要性

*** 成果

- 证书：计算机 4 极网络工程师，英语四六级
- 国家奖学金
- 2 篇 SCI 论文

*** 职业规划

- 完善 EE、CS 的功底，解决 CS 算法在硬件实现的问题
- FPGA 在 AI 和大数据领域，进行数据加速
- SPOC 与 ASIC
- 探寻 FPFA 在不同领域的作用，发掘应用场景，尝试 FPGA 的极限是什么，能否在后摩尔时代改变现有的计算架构（并行化）
  因为 FPGA 还属于较新的技术，还有很大的硬件工艺潜力，应用场景（微软阿里云的数据加速，AI 领域寒武纪的芯片，通信网络的并行处理器），中国在这一部分的发力很少，但是一些大公司已经在尝试了。

* Project
** AIPre

[[https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/2012062520UCAA2012_Bittner_Ruf_Final-1.pdf][2016paper: Direct GPU/FPGA Communication Via PCI Express]]
[[~/Documents/Terminus/gtc-express-gpudirect-rdma.pdf][2013DirectRDMA]]

AIPre 是 SSD 和 GPU 之间的 FPGA 部分，主要负责从 SSD 中读出 jpeg 文件字节流，解码为 RGB 像素信息，缩放到要求的大小，送到 GPU 中。
该项目分为三个部分：PCIe Switch，JPEGDecoder，FPGAonGPU。

我负责这个网络的设计 jpeg 解码的实现，JPEGDecoder。
*** repo
[[~/Documents/Terminus/Hardware/Apps/AIPre2/TestBench/AIPre2TopTB/README.md][Terminus README]]
*** CPU GPU FPGA
https://gitee.com/chengxinhust/graph-bed/raw/master/uPic/keWHgS.png

- CPUs : Ease of programming and *native floating point* support with complex and cumbersome memory systems, as well as significant operating system overhead.
- GPUs : Fine grain SIMD processing and *native floating point* with a streaming memory architecture and a more *difficult programming environment* . 功耗极大
- FPGAs : Ultimate flexibility in processing, control and interfacing, at the extreme end of programming difficulty and lower clock rates with only *cumbersome floating point support* .

communication between FPGA and GPU requires the FPGA to map its memory (on chip or otherwise) onto the PCIe bus so that the GPU may read or write it directly as needed.

测试，nVidia GeForce GTX 580，V6LX240T-1 Xilinx FPGA， a modern Intel six core CPU。
现在，GPU-FPGA 的速度基本和 GPU-CPU 速度一致；CPU 处理图片的速度远远低于 FPGA 处理图片的速度。
*** 项目框图

需要讲清楚：流程图，亮点是什么，怎么提高效率，怎么实现目标？

AIPre 的框图，可用于向面试官讲述项目重点
#+ATTR_ORG: :width 400 #+ATTR_latex: :width 40 #+ATTR_HTML: :width 40
[[file:figures/AIPre.png]]

JPEG Parser: 找到所有的以 *FF* 开头的 tag，提取有用的信息：DQT，DHT 和图片数据，送到下一模块: 流水化
Huffman: 对每个颜色编码值进行 Huffman 解码，1～16bit 转换到 8bit（高 4bit 是 0 的个数，低 4bit 是真实数据长度），读取数据，每 64 个组成一个 8*8 的块，送到下一模块: 查表是一个耗时耗空间的过程，使用范式 Huffman 优化
IDCT: 乘加运算，将频域值转为色域值，得到每个像素 RGB，组成图片，送到下一个模块
Resizer: 通过相邻像素点的合并和复制，缩放图片尺寸，送到 GPU

**** 流水线是什么？怎么实现的？

流水线设计实际上就是把规模较大、层次较多的组合逻辑电路分为几个级，在每一级插入寄存器组暂存中间数据。使得一个 clk 处理编程多个 CLK 处理。
K 级的流水线就是从组合逻辑的输入到输出恰好有 K 个寄存器组（分为 K 级，每一级都有一个寄存器组）, 上一级的输出是下一级的输入而又无反馈的电路。

特点：
- 较大的组合逻辑分为几个较小的逻辑
- 逻辑之间用寄存器保存中间数据，两个寄存器之间的组合处理数据
- *没有反馈电路*
- 每个时钟送入数据，延迟数个 clk 后，持续输出数据


1. 问题：有反馈的电路，怎么流水化
   可以通过判断一次逻辑是否可以处理完，当前输入以及不同输入之间是否是强耦合，判断是否有反馈回路。如果有，改逻辑，或者加预处理然后并行化。

   必须处理完上一个 tag 之后，才知道下一个 tag 在哪？对于输入的 256bit，如果不知道上一个 256bit 已经处理的位数，是无法判断本次处理的起始位置。
   这个就是每次输入数据的强耦合。不能流水化。

   在找 tag 步骤，是不能流水线的。

   在处理 tag 的内容是可以流水化的。
   去掉 FF00 中的 00，其实就是移位操作，把某一个位置的数据往前移动 n 位。
   流水化的操作逻辑，找到原本位于 n 位置的数据，计算移位之后的数据是在 n-1 还是 n-2，之后就是对应赋值就可以了。
2. 预处理的要求是什么
   预处理是为了去掉反馈回路，可以有多个 CLK
**** 最大工作频率多少？怎么实现的？

400MHz，静态时序优化，打断关键路径

*** 框图解释
**** 设计流程

- 时序图：模块接口信号，模块内部块的接口信号
- 内部功能块设计 block design： 模块的功能，数据流向，实现思路
- 代码实现：
- 功能测试：
- 时序分析：
- 电路验证：

**** 设计接口

data 和 data valid in 必须绑定；
data first in 必须要有；
data last in 不一定要有，除非对最后的数据标志有状态机的需求
data padding in 不一定要有，除非数据有效位数难以判断
fifo full in 下一模块是否可以发数据

fifo full out 告诉前一模块是否要发数据

**** 速度不匹配时采用乒乓操作
速度关系：
- Parser： 256b/clk --> 256/8 * 400 * 1000 KB/s --> 1280 * 10000 KB/s --> 100Gb/s --> 1 万图片/s ： 通过工作频率和接口位宽计算得到
- Huffman: 1 千图片/s： 实际计算得到，由于压缩可能在 10 到 40 倍之间，所有无法计算出来
- IDCT：   1block/clk --> 8*8/6 pixel/clk --> 640/8 * 480/8 * 6 clk / pic --> 400 M / 28800 pic / s = 13888 pic/s ：通过工作频率和位宽计算得到

所以为了速度匹配，使用 10 个 Huffman，parser 和 IDCT 各一个

速度不匹配:由于 parser 模块和 IDCT 模块都可以 fully pipeline，但 Huffman Decoder 模块只能用状态机，一次的输入需要多个 cycle 处理，Huffman 速度慢。
为了使得 parser 和 IDCT 不会空闲，使用多个 Huffman Decoder(1:10:1:1)，采用乒乓操作，parser 的每个图片的输出，送到不同的 Huffman Decoder.

1. 问题：parser 产生的图片需要缓存吗？控制逻辑怎样的
   是的，根据乒乓操作，每个 Huffman 需要缓存接收数据，之后处理。

   parser 是串行处理一张张图片的，选择一个空闲的 Huffman，送一个图片的数据，缓存起来，因为 Huffman 处理时间很长，parsr 就会给下一个空闲的 Huffman 送数据。
   这样的弊端：1. 模块的启动时，只有一个 Huffman 是工作的，全部 huffman 启动时间很长。 2. Huffman 需要设计缓存接口，或者需要一个很大的双口 RAM。
   改进措施：1. parser 在处理图片信息的时候，是可以随时停下来处理其他图片的。 2. 在 parser 前面加 arbiter，可以根据 parser 的需要，送不同的图片的一部分给 parser，这样可以减少不同 Huffman 的等待时间。3.其实我们有多个 parser 模块并行处理的时候，就是这样工作的，只是我们现在还没有走到这一步


2. 问题：10 个 huffmam 同时产生数据，都是直接送到 IDCT 吗？
   是的，但会有 iamge_id 和 block_id 作为标记，以区分和合并。
   因为本来，IDCT 的输入就是一个独立的单位，是 8*8 的像素块，已经解耦的操作，和图片本身关系不大。

   image id 在 parser 每次读入新图片 jpeg_data_first_in 时，序号加 1；
   block id 在 Huffman Decoder 处理和 8*8block 或者遇到 EOB 时，序号加 1.

**** 串行和并行

FPGA 进行并行处理时，不是逐字节处理，而是一下处理一整块数据，每次处理的数据必须解耦，没有反馈电路。

串行可以逐字节处理，前后直接相关，解决了前面，才能解决后面。

*** JPEG

jpeg 是图像文件压缩编码算法
1. DCT：
   有损的离散余弦变换，将色域值转换到频域值，每个 block 中的数值差别很小。IDCT 将 8*8 的 block 中有效非零值放在左上角，8bit 数值范围-128 到 127，其他为 0.
2. Huffman 编码：
   压缩算法：将 8bit 数据转为 1bit~16bit，根据数值出现的频率进行编码，频率高的更短。
   将源码和 huffman 码放在 Huffman 树中，为了节省保存 Huffman 码的空间，采用范式 huffman，只用 16 个 8bit 数就可以。源码还是不做更改，全部保存。

   行程编码：前 4 个 bit 是 0 的个数，后 4 个 bit 是数据的长度（huffman 码最大只有 16 位）。long-run 编码可以有效减少 huffman 源码的数量。
3. 数据流特点：
   数据流---最小编码单元 MCU---数据单元与颜色分量 YCbCr---颜色分量单元 block
   一个 MCU 通常取图片 16*16 像素点，将其每个像素点 RGB 转换 YCbCr，得到 Y16*16, Cb16*16,Cr16*16，通过下采样 4:1:1，将 16*16 分为 4 个 8*8，得到 Y[1]8*8，Y[2]8*8，Y[3]8*8，Y[4]8*8，Cb8*8，Cr8*8。之后都以 8*8 的数据进行压缩处理。

颜色分量单元内部综合运用了 RLE 行程编码和哈夫曼编码来压缩数据

*** Parser

1. DQT：tag+length+table（64*8bit）
2. DHT：tag+length+count（count 转化为 huffman 表）
3. image： FF{00} --> FF, FF{FF}_n{xx} --> FF 后跟一个 tag{xx}, FF{D0~D7}: RSTn, FF{D9} EOI, FF{xx} --> xx

*** Huffman

哈夫曼编码的关键是如何降低哈夫曼编码树的存储空间。

范式哈夫曼编码要求，码字是连续二进制，长度不变时，加 1；长度增加时，加 1 再添 0。
JPEG 中 DHT 中位置为 n 存储的是 *长度为 n 的码字数量* ，最长为 16。根据最小码和最小码地址，由此可得到 huffman 表。

*** IDCT

把频域转为色域的数。

大量的乘加运算，适合用 DSP 实现。但需要将长的运算分为多个短的运算。
例如，连续 5 个数的乘法，如果 DSP 来做，也是一个很长的组合逻辑；64 个乘法结果相加，也是很长的组合逻辑。所以必须打断，从算法上简化过程。

1 个 8*8bit 2D-IDCT ==> 8 个 8bit 1D-IDCT--> transpose -->8 个 8bit 1D-IDCT --> transpose

使用 DPS 的数量：8*2 个 IDCT 模块，一个 IDCT 模块使用 18 个 DSP，总共使用(* (* 8 2) 18) = 288。
考虑到 DSP 的复用，16 个 16bit 的乘法使用 8 个 DSP，还有 2 个 24bit 的乘法，使用 2 个 DSP，每个 IDCT 使用 10 个，总共使用(* 10 (* 8 2)) = 160

*** 性能

[[*速度不匹配时采用乒乓操作][每个模块的带宽]]
- 最大频率 400M
- 完全 pipeline
- 比上一代增快一倍
- 比常见快 30%

面积：
| FPGA Board     | Arria 10          |                  |                   | Stratix 10       |                  |                   |
|----------------+-------------------+------------------+-------------------+------------------+------------------+-------------------|
| module name    | JPEG Parser       | Huffman Decoder  | IDCT              | JPEG Parser      | Huffman Decoder  | IDCT              |
| Total Register | 10187             | 9384             | 29843             | 14333            | 10889            | 23361             |
| ALMs           | 10213/427,200(3%) | 6708/427,200(2%) | 10160/427,200(2%) | 9134/933,120(1%) | 5350/933,120(1%) | 10553/933,120(1%) |
| DSPs           | 0                 | 0                | 160/1518(11%)     | 0                | 0                | 128/5760(2%)      |
| 900mv/100C     | 400.48MHz         | 408.72MHz        | 402.74MHz         | 402.66MHz        | 403.36MHz        | 435.92MHz         |
| 900mv/0C       | 437.83MHz         | 439.37MHz        | 374.67MHz         | 401.77MHz        | 409.2MHz         | 415.8MHz          |

每个 FPGA 的 ALM 的数量在 50 万到 100 万之间，每个模块最大使用量不超过 2%。
4 个模块使用量不超过 10%，乒乓操作之后使用量不超过 20%。其他空间用于其它模块的实现。

stratix10 的 DSP 数量比之前的增加很多，为 AI 提供了基础。

** Terminus

项目负责人：lidong，熊勇强，程鹏，曲磊

Terminus 是为了改变数据中心现在的以 CPU 为核心的架构，改为以器件为核心的架构。绕过 CPU，各个器件之间可以直接通信。

因为现在的数据传输都是 CPU 与 CPU 的通信，但 CPU 的数据传输很慢（每一次传输需要 2 个指令，数据需要先放在 CPU 寄存器中再拿出来），CPU 的带宽和网络、固态硬盘、GPU 等算力设备的带宽差距很大。

Terminus 的主要方式，是在每一个现有服务器上，增加一块 FPGA 板卡，和各个器件的总线以及远程的服务器的 FPGA 相互通信。

Terminus 可以简单的认为，是一个 FPGA 的 PCIe switch，实现了高速 DMA 和 RDMA。

Terminus 在之前 2016 年的项目 Catapult 的基础上，实现了更多设备的接入，并增加了 FPGA 的硬件逻辑，用于完全代替 CPU 的简单工作。

常见器件的带宽数据总结如下
| interconnect    | rate per lane (GT/s) | lanes (in + out) | data rate |
|-----------------+----------------------+------------------+-----------|
| PCIe3.0         |                    8 |            16+16 | 16GB/s    |
| PCIe4.0         |                   16 |            16+16 | 32GB/s    |
| NVLink1.0       |                   20 |              8+8 | 20GB/s    |
| NVLink2.0       |                   25 |              8+8 | 25GB/s    |
| DDR4-2133       |                2.133 |            64+64 | 17.1GB/s  |
| DDR4-3200       |                  3.2 |            64+64 | 25.6GB/s  |
| P100 PCIe       |                  0.7 |        4096+4096 | 360GB/s   |
| V100 NVLink     |                   25 |                6 | 150GB/s   |
| V100 PCIe4.0*16 |                   16 |               16 | 32GB/s    |
| NVMe PCIe3.0*4  |                    8 |                4 | 4GB/s     |

深度网络处理图片的速度 1 块 V100GPU
ResNet 6954 images/s
GoogleNet 12352

CPU 处理图片速度  单核
300 images/s

*** FPGA 选型
**** stratix 10

1. 英特尔® Stratix® 10 GX FPGA
   专为满足高吞吐量系统的高性能要求而设计，可提供高达 10 万亿次的浮点性能，其收发器在芯片模块应用、芯片到芯片应用和背板应用中可支持高达 28.3 Gbps 的速度。

2. 英特尔® Stratix® 10 SX SoC FPGA（不选，没有 ARM 需求）
   不仅具有英特尔® Stratix® 10 GX 设备的所有特性，还提供了搭载 64 位 4 核 ARM* Cortex-A53 处理器（提供所有密度）的硬核处理器系统。

3. 英特尔® Stratix® 10 TX FPGA（不选，没有通信需求，通信物理层不负责）
   将 H-和 E-tile 收发器相结合，提供了业内最先进的收发器功能。E-tile 提供双模收发器功能，允许单个收发器通道在 PAM-4 模式下以最高 56 Gbps 的速度运行，或在 NRZ 模式下以最高 28.9 Gbps 的速度运行。英特尔® Stratix® 10 TX FPGA 还支持 Stratix GX 和 SX 变体的其他突破性创新。

4. 英特尔® Stratix® 10 MX FPGA（选，内存带宽高）
   将英特尔® Stratix® 10 FPGA 和 SoC 的可编程性与灵活性和 *3D 堆叠高带宽内存* 2 (HBM2) 整合至单个封装中。英特尔® Stratix® 10 MX FPGA 支持 H-tile 收发器和 E-tile 收发器。内存之间通信带宽很高

5. 英特尔® Stratix® 10 DX FPGA（不选，自己做 PCIe）
   是首款支持英特尔® 超级通道互联（英特尔® UPI）以直接一致性的方式连接未来特定英特尔® 至强® 可扩展处理器的 FPGA 设备。它们包括传输速度为 16GT/秒的 PCIe* Gen4 接口（最高 x16 配置）和支持特定英特尔® 傲腾™ 数据中心级持久内存的全新内存控制器。

6. 英特尔® Stratix® 10 NX FPGA（不选，没有 DSP 需求）
   一个经过人工智能 (AI) 优化适用于高带宽、低延迟、人工智能加速应用的 FPGA。英特尔® Stratix® 10 NX FPGA 通过人工智能优化的计算模块提供经过加速的人工智能计算解决方案，INT82 吞吐量超过标准英特尔® Stratix® 10 FPGA DSP 模块 15 倍及以上；封装 3D 堆栈的高带宽 DRAM；以及高达 57.8G PAM4 收发器。

|--------------------+--------------+-------------+-------------+---------------+---------------+---------------|
|                    | GX FPGA      | SX SoC FPGA | TX FPGA     | MX FPGA       | DX FPGA       | NX FPGA       |
|--------------------+--------------+-------------+-------------+---------------+---------------+---------------|
| 逻辑容量 (KLE)     | 378 - 10,200 | 378 - 2,073 | 378-2,753   | 1,679 - 2,073 | 1,325 - 2,753 | 1,679 – 2,073 |
| Arm® Cortex®-A53   | -            | 是          | 选项        | -             | 选项          | -             |
| 内存支持           | DDR4 / 其他  | DDR4 / 其他 | DDR4 / 其他 | DDR4 / 其他   | DDR4 / 其他   | DDR4 / 其他   |
| 最大收发器数据速率 | 28.3         | 28.3        | 28.9 /57.8  | 28.9 /57.8    | 28.9 /57.8    | 28.9 / 57.8   |
| PCIExpress         | 3x16         | 3x16        | 3x16        | 3x16          | 4x16          | 3x16 /  4x16  |
| UPI                | -            | -           | -           | -             | 是            | -             |
| Tensor 模块        | -            | -           | -           | -             | -             | 是            |
|--------------------+--------------+-------------+-------------+---------------+---------------+---------------|

**** stratix 10 MX
考虑到内存容量大，带宽高，选择
- MX1100
- MX1650
- MX2100：最高容量的型号，选择

*** DONE AIPre terms
    CLOSED: [2020-08-18 Tue 09:35] SCHEDULED: <2020-07-19 Sun 14:30>

**** DONE NVMe
     CLOSED: [2020-10-05 Mon 09:50]
**** DONE PCIe, PCIe switch
     CLOSED: [2020-10-05 Mon 09:50]
**** DONE area & speed
     CLOSED: [2020-10-05 Mon 09:50]
**** DONE DMA, RDMA
     CLOSED: [2020-10-05 Mon 09:50]
**** DONE WebRTC
     CLOSED: [2020-10-05 Mon 09:50]
** 光纤燃油液位传感器
*** 传统传感器
**** 电容传感器
精度高；易受电磁干扰，电火花，校准麻烦
**** 超声波
容易声速校准；气泡影响传播路径
**** 磁致伸缩
精度高；昂贵
**** 机械
精度低；易受机械干扰
*** 主要贡献
1. 找到最佳斜刨角度
   通过菲涅尔反射计算，COMSOL 仿真
2. 将工程问题变为研究问题
   - 没有钻研信号滤波，考虑重新设计传感器；信噪比
   - 使用光调制深度，在全反射范围之内找局部最优
3. 专注于一个问题，简化结构
   - 复杂的光纤传感器更专注于调整光路，而不是光强
   - 形状复杂无法分析，无法证明
   - 只有一个斜刨角度的变量，做最优化
*** 解决的问题
1. 精度
   传感器最直接的表现就是精度低，更深一步的原因，是信号弱，受噪声影响大。
   一种处理方式是信号处理：数值平均，差分放大，锁相放大。这种方法直接，能短期看到成效，仅仅是算法或者局部改电路。
   但是如果精度达不到要求，无法分析滤波后的数据，无法进一步提高精度。
   另一种方法是从根源解决信噪比的问题。重新设计传感器，风险太大。设计者需要做充足的工作正面设计的有效性，这正式一个只会追求进度的工程所没有。
2. 设计方法
   物理分析->仿真->最优解
3. 从可行性分析到最优化设计
   为实验室的工作提供了一种新的工作方法
