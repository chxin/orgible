* HDL
** Verilog demo
*** code demo and test bench demo
    [[file:~/Documents/Garage/template/hdl/verilog/README.org][demo]]
    [[~/Documents/Snippet/HDL/counter/makefile][ripple carrier counter]]

** DONE verilog simulation and synthesis on MacOS
   CLOSED: [2020-07-02 Thu 17:01]
   :PROPERTIES:
   :ID:       D9C15D64-25C0-4776-9D50-E8B24117506F
   :END:
   :LOGBOOK:
   CLOCK: [2020-07-01 Wed 11:14]--[2020-07-01 Wed 11:26] =>  0:12
   :END:
 [2020-07-01 Wed 11:14]

*** code complier
 #+begin_src shell
 brew install icarus-verilog
 brew install verilator
 brew cask install xquartz
 brew cask insatll gtkwave
 cpan install Switch
 alias gtkwave = /Applications/gtkwave.app/Contents/Resources/bin/gtkwave
 #+end_src

 if Switch located in '/usr/local/Cellar/perl/...'
 move it to Library folder:
 #+begin_src shell
 sudo cp /usr/local/Cellar/perl/5.*/lib/perl5/site_perl/5.*/Switch.pm /Library/Perl/5.*/
 #+end_src
*** verilog synthesis
    :PROPERTIES:
    :ID:       AC48B934-8FE4-4C2A-9D37-42251687425D
    :END:
 #+begin_src shell
 brew install yosys
 brew install graphviz
 #+end_src

**** code example
 #+begin_src verilog
 module counter (clk, rst, en, count);
    input clk, rst, en;
    output reg [3:0] count;
    always @(posedge clk)
       if (rst)
          count <= 4'd0;
       else if (en)
          count <= count + 4'd1;
 endmodule
 #+end_src

**** synthesis commands
 creat show_rtl.ys with following command:
 #+begin_src shell
 # read design
 read_verilog counter.v
 hierarchy -top counter
 # high-level synthesis
 proc; opt; fsm; opt; memory; opt; #techmap; opt;
 write_verilog synth.v
 #+end_src

 convert verilog code to net table
 #+begin_src shell
 # get net table after synthesis
 yosys show_rtl.ys
 # change circuit diagram to image
 yosys -p "prep; show -stretch -prefix counter -format dot" counter.v
 # view image
 dot counter.dot -T png -o counter.png
 #+end_src
** DONE 状态机FSM
   CLOSED: [2020-07-02 Thu 16:59]
   FPGA状态机电路综合分析 http://blog.chinaaet.com/weiqi7777/p/40172

   三段式：状态转移，每个状态的输出，状态转移规律
*** 好的状态机的标准
设计、综合、维护
 1. 逻辑控制：
    FSM要完备, FSM不会进入死循环，不会进入非预知的状态，不会由于扰动进入非设计状态。
    FSM的综合结果无毛刺（最好使用同步时序）；

 2. 达到速度面积要求：
    状态机能够被synthesis识别，优化

 3. 设计清晰易懂、易维护

*** 可综合
   - 使用one hot编码，parameter类型；
   - 状态机如果能被识别出来，会显示在状态机列表中；
   - next_state = state + 1不会被识别为状态机，next_state = state2则会被识别；
   - 三段式状态机，必须的

*** 设计方式

 状态转移一定是时序逻辑，因为要在每个时钟上升沿切换；
 状态转移规律一定是组合逻辑，不产生额外的时钟节拍，监视current state和data in的上升沿和下降沿（错误，应该是监视电平变化）；
 数据输出，可以是组合逻辑，也可以是时序逻辑，在每个时钟的上升沿。（时序逻辑利于减短路径，减少毛刺）。

 1. 一段式
    整个状态机在一个always模块，即描述状态转移，又描述状态的输入和输出。

 2. 两段式
    一个always模块采用同步时序描述状态转移；另一个模块再用组合逻辑判断状态转移条件以及输入输出。

    同步时序和组合逻辑分开，利于synthesis，添加约束条件，利于布线。

    描述输出用组合逻辑，容易产生毛刺，组合逻辑路径可能过长。

 3. 三段式
    一个always模块采用同步时序描述转移；一个always采用组合逻辑判断状态转移条件；另一个always模块描述状态输出，可以用组合电路，也可以用时序电路。

    其实，把三段式的第三个模块， 描述状态输出， 分开来写，就是一个组合逻辑产生输出的逻辑运算，和一个时序逻辑，对输出进行打拍。这样，把这个组合逻辑放在三段式的第二个模块中，也是一样的？第三个模块的作用也更清晰了，就是输出打一拍，减少毛刺。
*** 状态编码

 FPGA用one-hot code，只需要判断一个bit，组合电路简单，使用多个FF；没有binary code译码之后数据选择器的这一步。输出可能就是多个FF输出的线与。

 CPLD因为组合电路资源丰富，触发器资源较少，用binary和gray-code。
 Gray-code每次递增或递减只变化1bit，防止在状态转移中发生突变，使得状态转移更为稳定

*** demo

 #+begin_src verilog
 //第一个进程，同步时序always模块，格式化描述次态寄存器迁移到现态寄存器
 always @ (posedge clk or negedge rst_n) //异步复位
 if(!rst_n)
     current_state <= IDLE;
 else
     current_state <= next_state; //注意，使用的是非阻塞赋值


 //第二个进程，组合逻辑always模块，描述状态转移条件判断：根据当前状态和输入
 always @ (current_state or data_in) //电平触发；敏感信号可能不止这两个，建议用always @ (*)
 begin
     next_state = x; //要初始化，使得系统复位后能进入正确的状态
 case(current_state)
     S1: if(...)
         next_state = S2; //阻塞赋值
     ...
 endcase
 end

 //第三个进程，同步时序always模块，格式化描述次态寄存器输出
 always @ (posedge clk or negedge rst_n)
 ...//初始化
 case(next_state) // !!!!!根据下一个状态，不是当前状态
 S1:
     out1 <= 1'b1; //注意是非阻塞逻辑
 S2:
     out2 <= 1'b1;
 default:... //default的作用是免除综合工具综合出锁存器
 endcase
 end
 #+end_src

 为什么在第三个always描述输出模块中，根据next state而不是current statue呢？

 在时钟上升沿，current state变为next state。如果在同上升沿，判断current state，必然是没有没有改变的值。根据current state进行输出，该周期输出的就是上一个状态的输出。

 next state是组合逻辑，在该时钟上升沿必然就已经是下一个状态的值，因为在上一个上升沿就已经变了。

*** design process

 1. 确定输入
 2. 划分状态：每个状态 *仅根据输入就能直接进入下一个状态* ，不用运算之后才选择下一个状态。这样的考虑是，让状态和输入强相关，同时减小组合路径长度
 3. 确定每个状态的输出

 当然，如果，状态比较复杂，或者根据任务就能够分出不同的状态，以上步骤就可以倒序进行。

** CANCELLED RISC-V verilog                                       :CANCELLED:
   CLOSED: [2020-07-15 Wed 08:39]
   - State "CANCELLED"  from              [2020-07-15 Wed 08:39] \\
     用verilog实现RISC-v太复杂了，需要选择相对简单的核心功能实现就好，可以参考 ‘Verilog数字系统设计教程(第3版)’ 第17章

     我的初衷是学习verilog通信，使用状态机的方法，可以参考 ‘Verilog数字系统设计教程(第3版)‘ 第15.2和第16章。在微信收藏了[[https://mp.weixin.qq.com/s/h8rBaDSUbeCEXlNo_i8Sjw][verilog的SPI通信的实现]] [[https://mp.weixin.qq.com/s/clPUfGjKqnhMcp95xwHwkg][UART实现]]，可以参考
*** 五级流水线
 1. 取指（Cinstruction Fetch ）是指将指令从存储器中读取出来的过程。
 2. 译码（ Instruction Decode ）是指将从存储器中取出的指令进行翻译的过程。经过译码之后得到指令需要的操作数寄存器索引，可以使用此索引从通用寄存器组
 (Register File, Regfile ）中将操作数读出。
 3. 执行（ Instruction Execute ）常见部件为算术逻辑部件运算器（ Arithmetic Logical Unit, ALU)
 4. 访存（ Memory Access ）是指存储器访问指令将数据从存储器中读出，或者写入存储器的过程 。
 5. 写回（Write-Back ）是指将指令执行的结果写回通用寄存器组的过程
** DONE HDL IIC读写EEPROM
   CLOSED: [2020-08-27 Thu 11:32]
*** IIC

 IIC(inter integrated circuit)是双向二进制串行总线。数据线SDA，时钟线SCL

 byte传输应答机制；每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答

 基本的控制命令的思想是：命令先行，地址必为写命令；先地址后数据；读字节要用读命令，写字节不用写命令，直接写即可
**** 传输过程

 不忙状态，才可以启动传输功能； 时钟高电平期间，数据线的变化是 *启动* 或者 *停止* 信号； 时钟低电平期间，数据线的变化是 改变传输数据。

 1. 非忙状态： 数据线和时钟线都是高电平
 2. 启动传输： 时钟线高电平，数据线下降沿
 3. 数据传输： 时钟线高电平时，数据保持稳定，该数据被传输；时钟线低电平时，数据变化
 4. 接收应答： IIC接收端每收到一个字节之后，发出一个应答信号；发送端接收该应当信号。
 5. 停止传输： 时钟线高电平，数据线上升沿

**** 写EEPROM
写入地址
 - 控制器发送一个byte的命令，说明是对某个地址执行读或写操作（写操作）
 - EEPROM接收指令，传回应答
 - 控制器发送一个byte的存储地址
 - EEPROM接收地址，传回应答
写入数据
 - 控制器发送一个byte的命令，说明是对某个地址执行读或写操作（写操作）
 - 控制器发送数据
 - EEPROM接收数据，放到指定地址，传回应答
 - 控制器产生停止信号

**** 读EEPROM
写入地址
 - 控制器发送一个byte的命令，说明是对某个地址执行读或写操作（写操作）
 - EEPROM接收指令，传回应答
 - 控制器发送一个byte的存储地址
 - EEPROM接收地址，传回应答
读数据
 - 控制器发送一个byte的命令，说明是对某个地址执行读或写操作（读操作）
 - EEPROM接收指令，传回应答
 - EEPROM发送数据

*** TODO pre code

 第一个模块发送一个4bit的数据；第二个模块把4bit并行数据改为串行数据流，并用scl和sda数据线输出；第三个模块把串行的数据接收到，并4-16译码输出
 #+begin_src verilog
 // module1： send reg[3:0] every 100 clk

 #+end_src

** DONE 分频
*** 二分频
https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247483687&idx=1&sn=db1f0247303a0b9ce66b6b43b69946cd&chksm=cf0b8d00f87c041661d2e9c249c870be61eafd19f8275b730b97432798a6ae97fb29425556dd&scene=21#wechat_redirect
*** 偶数分频
https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247483911&idx=1&sn=77769d11c50ba8d2c603ac1fbdce89d5&chksm=cf0b8e20f87c0736100eeca5e44e10d43a863bd99ca199c0852598f21c26ede228805ea0d314&scene=21#wechat_redirect
*** 奇数分频
https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247483921&idx=1&sn=616575dda78bb116c56e42c75fc7e707&chksm=cf0b8e36f87c072096c2506642276dc6d50ebef2a1bda6c49f603cfb2d68310d6b20e15bb5de&scene=21#wechat_redirect
*** 半分频
https://blog.csdn.net/qq_34070723/article/details/100731708#3.半整数分频
*** 任意分频
https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247483926&idx=1&sn=31a5cca8da317e6fb5bf4184bb392f46&chksm=cf0b8e31f87c0727f28a9365f0c7bce8e4c520a8b95c3ea508934d179b68f7b56217c24459e4&scene=21#wechat_redirect
** TODO verilog端口连结规则
*** 端口声明
 端口列表中的所有端口必须在模块中进行声明，verilog中的端口具有以下三种了类型：input、output、和inout。
 在verilog中，所有的端口隐含地声明为wire类型
 如果输出类型的端口需要保存数值，则必须将其显式的声明为reg数据类型。output reg out;
 不能将input和inout类型的端口声明为reg数据类型，因为reg类型的变量是用于保存数值的，而 *输入端口只反映与其相连的外部信号的变化，并不能保存这些信号的值* 。
*** 输入端口
 从模块内部来讲，输入端口必须为线网数据类型
 从模块外部来看，输入端口可以连接到线网或者reg数据类型的变量。
*** 输出端口
 从模块内部来讲，输出端口可以是线网或者reg数据类型
 从模块外部来看， *输出必须连接到线网类型的变量* ，而不能连接到reg类型的变量。
*** 输入/输出端口
 从模块内部来讲， *输入/输出端口必须为线网数据类型* 。
 从模块外部来看， *输入/输出端口也必须连接到线网类型的变量* 。
** TODO 同步、异步FIFO
 https://blog.csdn.net/Pieces_thinking/article/details/78026326

 由于异步FIFO的读写时钟不一样，（采用两级寄存器同步+格雷码->消除亚稳态）
* FPGA
** DONE FPGA hardware
   CLOSED: [2020-07-30 周四 16:50] SCHEDULED: <2020-07-20 Mon 14:30>
   :LOGBOOK:
   CLOCK: [2020-07-15 周三 19:37]--[2020-07-15 周三 19:38] =>  0:01
   :END:
   时间点安排在：把 ‘FPGA原理与结构’ 读完一遍之后，参考了 ‘FPGA芯片架构设计与实现’ 之后
 需要参考 FPGA原理与结构 的第三章，再修改以下内容：

*** DONE sliceL & sliceM
    CLOSED: [2020-07-16 周四 19:13]
 https://blog.csdn.net/vivid117/article/details/102841135?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

 1. CLB(ConfigurableLogic Block)------含2个SliceL 或1个SliceL和1个sliceM，Slice总数的2/3是SliceL，1/3是SliceM。

   其区别主要在于，SLICEM 中含有能够把 LUT 资源重新整合为 RAM 或 ROM 的逻辑。这就是所谓的Distributed Ram。 而 SLICEL 则不具备此功能。
   所以 SLICEM 比 SLICEL 多了做存储器和移位寄存器的功能，Slicem用LUTs作为专属RAM(1LUT=64*1)或者移位寄存器SRL(1LUT=32bit SRL)。

   本质上，SLICEM的LUT，不仅有SLICEL的读出的端口，更有 *写入端口和时钟端口* ，用于对LUT内容的同步时序控制，而不仅仅是初始化时固定LUT内容。

 2. 移位寄存器 https://www.xilinx.com/support/documentation/application_notes/xapp465.pdf
   通常n输入的LUT可以配置为2^n的移位寄存器，可以通过地址A[n-1:0]配置移位寄存器的长度，也可以通过级联的方式扩展移位寄存器。
   其工作原理是，LUT是SRAM，本质上是RS触发器（两个反相器串联），本质上就支持移位操作，当配置为移位寄存器，其存储的内容每个时钟移位一次。地址A[n-1:0]可看作是地址选择端。
   但是，在一个slice中，虽然6输入查找表，但只能配置32bit寄存器，因为6输入分为2个5输入但输入引脚都相同，所以两个移位寄存器是相同的，只能算一个。或者2个16bit寄存器

 3. DRAM
   DRAM在WE为高电平时根据A[6:0]写入，在WE为低电平时根据DPRA[6:0]读
   小容量的DRAM可以用LUT实现，大容量可考虑用 18K 分区 RAM来实现。

 4. Slice
    FPGA的slice包含4个部分：
    (1) 逻辑功能产生器，也就是查找表[[*LUT][LUT]]，1个slice里包含4个6输入的查找表（每个6输入查找表可以分为2个5输入查找表，输入数据和地址相同，2个输出独立连接到FF），可配置成DRAM和移位寄存器。
    (2) 存储单元，也就是常说的触发器，1个slice里包含 *8个触发器。每4个触发器为一组* ，可配置成寄存器（D触发器或锁存器）。
    (3) 多路复用器，也就是1位宽的数据选择器，数量非常多，足够使用。一般的4：1MUX，使用6输入查找表实现的，8：1MUX可通过2个6输入查找表和一个原有MUX实现。
    (4) 进位逻辑，它与本列的上下slice的进位逻辑相连，实现数据运算时的进位操作。

 这里有一个概念：verilog中 reg [7:0] r1是可以直接赋值，但是reg r2 [7:0] 不能直接赋值。因为reg [7:0] 是8个触发器，给定输入即可；但reg r2 [7:0] 是查找表，只能给LUT地址然后逐个赋值。

*** DONE 可编程单元
    CLOSED: [2020-07-30 周四 16:50]

**** 基于查找表
**** 基于与或门阵列
**** 基于MUX

 对于n输入的逻辑函数，不能完备表示所有情况

*** DONE 查找表的实现
    CLOSED: [2020-07-30 周四 16:50]

**** 反熔断
不能重复使用
**** EEPROM或FLASH
**** SRAM
速度最快，但每次使用都要烧写
*** DONE book: FPGA设计与实现
    DEADLINE: <2020-07-17 Fri 21:00>
    :LOGBOOK:
    CLOCK: [2020-07-15 周三 19:01]--[2020-07-15 周三 19:37] =>  0:36
    CLOCK: [2020-07-15 周三 16:58]--[2020-07-15 周三 17:03] =>  0:05
    :END:

*** DONE Book: FPGA芯片结构与设计实现
    CLOSED: [2020-07-15 Wed 09:18]

    未读完，选择性参阅。
    :LOGBOOK:
    CLOCK: [2020-07-06 Mon 10:34]--[2020-07-06 Mon 10:35] =>  0:01
    CLOCK: [2020-07-05 Sun 21:49]--[2020-07-05 Sun 21:51] =>  0:02
    :END:
  [2020-07-05 Sun 21:49]

**** 三大基本单元
***** 逻辑单元
      :LOGBOOK:
      CLOCK: [2020-07-06 Mon 09:26]--[2020-07-06 Mon 10:34] =>  1:08
      :END:
  基于查找表(Look Up Table, LUT)的可编程逻辑单元主要由以下几部分组成:
  两个四输入的LUT，两个进位逻辑，两个可编程触发器DFF，还包含64个配置用的SRAM、信号产生模块以及控制逻辑等。每个可编程逻辑单元中还包含一个与门资源，用来实现有效的乘法运算。可实现组合逻辑电路和时序逻辑电路。

****** LUT

  LUT从本质上来说是四位地址的16x1的SRAM，每个地址存放一个数值。SRAM的输出，通过地址信息控制的NMOS MUX树。

  LUT本质上就是一个SRAM。它把数据事先写入RAM后，每当输入一个信号就等于输入一个地址进行查表，找出地址对应的内容，然后输出。

  7系列FPGA中的函数发生器实现为六输入查找表（LUT）。slice的4个函数发生器（A，B，C和D）中的每一个都有六个独立输入（A输入A1至A6）和两个独立输出（O5和O6）。

  1）函数发生器可以实现以下函数功能：
     - 任意定义的六输入布尔函数 •A1-A6输入 •O6输出
     - 两个任意定义的五输入布尔函数，只要这两个函数共享公共输入 •A1–A5输入 •A6驱动高 •O5和O6输出
     - 两个任意定义的布尔函数（3个和2个或更少输入）

******* LUT实现逻辑运算

  对于任何四输入的函数，都可以写出它的真值表，然后根据它的真值表在其寄存器中对应的位置存放为「1」和「0」。
  这样对应不同的4输入逻辑函数，通过译码电路转为SRAM输入地址，决定从哪一个SRAM单元读出信息，就得到不同的结果。

  其中四输入的LUT用来实现任意四输入的函数，通过两个LUT和一个MUX的组合可以实现任意五输入的函数，同时每个LUT还可以实现16x1的RAM和16x1的移位寄存器。

******* 设计LUT的输入数

  k输入的LUT需要2^k的存储单元，当K增大，实现LUT的硅面积指数增加，查找时间增加。
  考虑到功能，面积和性能的平衡，选择4输入

******* LUT的不足和优化

 查找表的高度灵活性和可配置性使得FPGA得到快速的发展和广泛的应用，也带来了面积和速度上的损耗
 1. 面积损耗，LUT未充分利用
    - LUT的复用

****** 存储单元

  可配置模块中的存储单元中的4个可以配置成边沿敏感D触发器，也可以配置成电平敏感的锁存器，另外4个只能配置成D触发器

  时序部分由具有使能端的可编程D存储器构成，上升沿或下降沿触发，由CLK和CLK反向进入一个MUX配置而成。也可以输出不通过D触发器，直接输出，组成组合逻辑

****** 进位逻辑
  一个专用的快速超前进位逻辑，以slice片中执行快速算术加法和减法，也可作为LUT输出函数与触发器资源之间的通道。

  进位链其实是不同Slice之间进位信息的最短固有连线，走线延迟最短，从而加快算数运算的速度。

******* 算数运算

  FPGA中的加法运算，最常用且消耗资源最少的是行波加法器（一位全加器的级联），使用两个异或和一个MUX，关键路径在进位链上。
  input A, B; output S, C;
  S = A ^ B ^ C;
  C = A & B + A ^ B & C;
  为了提高加法器的工作频率，引入了进位链，贯穿了可编程逻辑阵列的每一行，以保证相互之间连线最短。

******* 乘法运算

  加入了一个与门，复用了LUT的逻辑功能
  
***** IO
***** 连线
**** 时钟
     :LOGBOOK:
     CLOCK: [2020-07-05 Sun 21:51]--[2020-07-05 Sun 22:04] =>  0:13
     :END:
     门控时钟通过不使用的时候断开CLK，可以降低功率

     时钟网络是时钟源和寄存器时钟端之间的一系列组合逻辑和金属连线组成的网格结构，设计优劣在一定程度上决定这FPGA系统整体的速度、功耗和面积。

     - 树形时钟网络：输出端都是独立分支
     - 网格时钟网络：输出端通过纵横金属网格连接起来

**** 电源
     :LOGBOOK:
     CLOCK: [2020-07-05 Sun 22:04]--[2020-07-05 Sun 22:15] =>  0:11
     :END:
     电源/地线网络分析和漏电优化技术（电源完整性）

***** 电源网络结构

      - 树形
      - 网状

***** 电源完整性

      - IR-drop
        导线电阻导致的压降
      - 电感效应
      - 地反弹
        地线网络的返回电流，会产生噪声，导致不正确的电路信号翻转

**** DDR
**** 延时
** FPGA资源利用
     :LOGBOOK:
     CLOCK: [2020-07-17 周五 10:53]--[2020-07-17 周五 11:27] =>  0:34
     CLOCK: [2020-07-17 周五 09:32]--[2020-07-17 周五 10:33] =>  1:01
     :END:
把逻辑功能定位到专用硬件资源，参考[[*FPGA hardware][FPGA Hardware]]

*** 寄存器

有两种：LB中的DFF，IOB中的寄存器
- 按照Reset、set、和CE的优先级顺序初始化寄存器，
- 每个slice包含2个寄存器，每个寄存器的Set和Reset信号必须同时是同步的或者同时是异步的，才能综合到一个slice中。
- 同步设计推荐使用同步Reset，异步全局reset信号使用大量布线资源且路径延时长，尽量不要使用局部异步Reset，可以提高FPGA电路的可靠性，使电路能够更加有效地映射到FPGA结构资源中。
- 同步设计要求不使用门控时钟，因为门控时钟会造成毛刺。时钟使能CE在同步设计中起到了代替门控时钟的作用。
- 在所有模块边界实现寄存器输出，可以保证模块内的组合逻辑输出延迟不会发生变化，模块内可以设置为更新时保留大部分的布局布线，实现增量设计。

*** MUX

FPGA仅有三个2选1地MUX，其他需要用LUT实现。
- IF语句产生优先级编码器，CASE语句产生复杂编码器。
  优先编码器：多个二选一MUX级联，输出位于最后一级MUX的输出，先出现的IF位于后级MUX，路径较短。
  复杂编码器：多个LUT并联，减少逻辑级的数量。可以看作是一个N输入的MUX（可能由多级LUT或者小MUX级联）。
- 独热码case语句使用更多的查找表，但需要更少的逻辑级，对提高时序性能很有必要。
  独热码相比于格雷码：格雷码case语句综合之后是一个N输入的MUX，每个输入端连接一个由若干input组成的组合逻辑（查找表）。
  独热码，相当于已经把MUX拆开了，每一位单独控制一条input的组合逻辑，所以省了一级逻辑。
  但是独热码怎么选择某一个进行输出呢？只有一个有输出其他都不输出，所有输出或逻辑连接？可能是所有输出直接线与
- 对输入和选择信号寄存，特别对具有大量输入信号的多路选择器有益，因为其结构需要更多的逻辑级。通过对输入与选择信号锁存，可以有效地将大组合路径（多个LUT）延迟流水分割为多个小延迟。

**** 使用LUT构建MUX

类似于SAM的字扩展，低位并联，高位选通。高位选通时能使用内置MUX就用，不能用才用查找表。
对于2输入1选择，直接使用4-LUT即可。
对于4输入2选择，直接使用6-LUT即可。
对于8输入3选择，分为两个4输入2选择并联，低4位和高4位用SEL低两位选择构成两个6-LUT，第一级的两个输出连接到MUX或者LUT用SEL高位选择。
对于16输入4选择，分为4个4输入2选择（SLE低两位）并联，第一级的四个输出和SLE的高两位可以再用一个6-LUT。

*** TODO 硬件利用率

FPGA相比较于ASIC，会有大量的资源浪费，例如6-LUT只用部分，SLICE中的硬件只用部分。
1. 提高LUT利用率
   - FPGA设计： 一个6-LUT分为两个5-LUT，有公共引脚，通过把两个有共同输入的逻辑函数放到2个5-LUT中。
   - 代码风格：
2. 提高SLICE利用率
   - FPGA设计：
   - 代码风格：每个SLICE中的控制信号一致(clk, en, rst)；每个slice包含2个寄存器，每个寄存器的Set和Reset信号必须同时是同步的或者同时是异步的，才能综合到一个slice中。

*** DONE Book:Recommended HDL coding style
    CLOSED: [2020-08-29 Sat 09:35]
    :LOGBOOK:
    CLOCK: [2020-08-28 Fri 09:42]--[2020-08-28 Fri 09:54] =>  0:12
    :END:
  [2020-08-28 Fri 09:42]
  synthesis tools detect sets of operators that can be replaced with the megafunctions for device families that have dedicated RAM blocks, or may map them directly to device memory atoms.
**** DONE Using Quartus Templete and megafunction
     CLOSED: [2020-08-28 Fri 09:55]
**** DONE 乘法器和DSP
     CLOSED: [2020-08-29 Sat 09:39]
     :LOGBOOK:
     CLOCK: [2020-08-28 Fri 09:57]--[2020-08-28 Fri 10:16] =>  0:19
     :END:
  register packing: 把输入输出寄存器打包放进DSP中

  在DSP中添加寄存器，可以加快时钟工作频率，但会引入3个时钟延时。
**** DONE memory: ROM and RAM
     CLOSED: [2020-08-29 Sat 09:40]
     :LOGBOOK:
     CLOCK: [2020-08-28 Fri 10:26]--[2020-08-28 Fri 11:32] =>  1:06
     :END:
  memory blocks in the newest devices from Altera are synchronous, RAM designs that are targeted towards architectures that contain these dedicated memory blocks must be synchronous to be mapped directly

  ROMs are inferred when a CASE statement exists in which a value is set to a constant for every choice in the case statement

  想要初始化，使用 initial 块，这是可综合的，在initial块内，也可以使用$readmemh()

**** Register
***** power up value
  default value: 0
  1. aclr: add NOT gate push-back
  2. aload:
  3. signed integer 100..001: left end of integer range

***** secondary control signal
  The priority order for secondary control signals in Altera devices differs.
  If your design requirements are flexible regarding priority, verify that the secondary control signals meet design performance.
  clock enable > asynchronous clear > asynchronous load > enable > synchronous clear > synchronous load > data

  if(aclr) ...  else if(aload) ... else if (en) ...

  verilog的时序电路不能把电平信号放在敏感列表中，但VHDL可以
***** latches
  latch是组合逻辑

  latch必要性：在时钟沿之外的时间，一个信号被赋值并锁存，例如异步复位。

  建立安全latch，
**** 时钟选择
**** 状态机
  使用one hot编码，parameter类型；
  状态机如果能被识别出来，会显示在状态机列表中；
  next_state = state + 1不会被识别为状态机，next_state = state2则会被识别；
  三段式状态机，必须的

**** 加法树
  4-LUT能够在一个LE中实现A+B，6-LUT能够A+B+C。所以二叉或者三叉加法树能够实现最优的结果
***** pipelined
  通过寄存器保存加法树的每个节点
***** none-pipelined
  通过括号，分割计算顺序
**** 比较器
  通过进位链，6-LUT可以实现两个3bit的比较，4-LUT只能两个1bit比较
** FPGA逻辑
*** 状态机
[[*状态机FSM][状态机设计]]
FPGA状态机电路综合分析 http://blog.chinaaet.com/weiqi7777/p/40172
*** NEXT 硬件算法
参考 Book:FPGA原理与结构 第六章
**** 流水线
**** 并行计算和Flynn分类
SISD(CPU); SIMD(GPU); MISD(pipeline); MIMD(multi-core)
**** 脉动算法
**** 数据流机
2D-IDCT的实现：可以看作是pipeline的发展，但pipeline不会在不同的pipeline之间交换数据
**** 流处理
序列检测器11011011
**** 细胞自动机
**** 硬件排序算法
**** 模式匹配

** DONE FPGA设计思想
   CLOSED: [2020-08-26 Wed 21:33]

*** 面积与速度的平衡与互换

 面积指一个设计消耗FPGA/CPLD的逻辑资源的数量，对于FPGA可以用消耗的FF（触发器）和LUT（查找表）来衡量，更一般的衡量方式可以用设计所占的 *等价逻辑门数* 。

 速度是指整个工程稳定运行所能够达到的最高时钟频率，它不仅和FPGA内部各个寄存器的建立时间、保持时间以及FPGA与外部器件接口的各种时序要求有关，而且还和两个相邻的寄存器间（有紧密逻辑关系的寄存器）的逻辑延时、走线延时等有关

 要求一个同时具备设计面积最小、运行频率最高是不现实的。更科学的设计目标应该是在 *满足设计时序要求（包括对设计频率的要求）的前提下* ，占用最小的芯片面积。或者在所规定的面积下，是设计的时序余量更大、频率跑的更高。这两种目标充分体现了面积和速度的平衡的思想。

 作为矛盾的两个组成部分，面积和速度的地位是不一样的。相比之下， *满足时序、工作频率的要求更重要一些* ，当两者冲突时，采用速度优先的准则。

 从理论上讲，如果一个设计时序余量较大，所能跑的速度远远高于设计要求，那么就通过功能模块的复用来减少整个设计消耗的芯片面积，这就是用速度的优势换取面积的节约。反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么一般可以通过将数据流串并转换，并行复制多个操作模块，对整个设计采取乒乓操作和串并转换的思想运行。

*** 硬件原则

 硬件原则主要针对HDL代码编写而言：Verilog是采用了C语言形式的硬件的抽象，它的本质作用在于描述硬件，它的最终实现结果是芯片内部的实际电路。所以评判一段HDL代码的优劣的最终标准是： *其描述并实现的硬件电路的性能* ，包括面积和速度两个方面。

 评价一个设计的代码水平较高，仅仅是说这个设计是由硬件想HDL代码这种表现形式的 *转换更加流畅、合理* 。而一个 *设计最终性能，在更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性* 。（HDL代码仅仅是硬件设计的表达形式之一）

 初学者片面追求代码的整洁、简短，是错误的，是与HDL的标准背道而驰的。正确的编码方法，首先要做到对所需实现的硬件电路胸有成竹，对该部分的硬件的结构和连接十分清晰，然后再用适当的HDL语句表达出来即可。

 另外，Verilog作为一种HDL语言，是分层次的。系统级--算法级--寄存器传输级--逻辑级--门级--开关级。构建优先级树会消耗大量的组合逻辑，所以如果能够使用case的地方，尽量使用case代替if.....else......

*** 系统原则

 系统原则包含两个层次的含义：更高层面上看，是一个硬件系统，一块单板如何进行模块花费和任务分配， *什么样的算法和功能适合放在FPGA里面实现* ，什么样的算法和功能适合放在DSP/CPU里面实现，以及FPGA的规模估算数据接口设计等。具体到FPGA设计就要对设计的全局有个宏观上的合理安排，比如时钟域、模块复用、约束、面积、速度等问题，在系统上模块的优化最为重要。

 一般来说实时性要求高，频率快的功能模块适合FPGA实现。而FPGA和CPLD相比，更适合实现规模较大、频率较高、寄存器较多的设计。使用FPGA/CPLD设计时，应该对芯片内部的各种底层硬件资源，和可用的设计资源有一个较深刻的认识。

 比如FPGA一般 *触发器资源丰富* ，CPLD的组合逻辑资源更加丰富。FPGA/CPLD一般是由底层可编程硬件单元、BRAM、布线资源、可配置IO单元、时钟资源等构成。

 底层可编程硬件单元一般由触发器和查找表组成。Xilinx的底层可编程硬件资源较SLICE，由两个FF和2个LUT构成。Altera的底层硬件资源叫LE，由1个FF和1个LUT构成。使用片内RAN可以实现单口RAM、双口RAM、同步/异步FIFO、ROM、CAM等常用单元模块。

*** 同步设计原则

 异步电路的逻辑核心是用组合逻辑电路实现，比如异步的FIFO/RAM读写信号，地址译码等电路。电路的主要信号、输出信号等并不依赖于任何一个时钟性信号，不是由时钟信号驱动FF产生的。 *异步时序电路的最大缺点是容易产生毛刺* ，在布局布线后仿真和用逻辑分析仪观测实际信号时，这种毛刺尤其明显。

 同步时序电路的核心逻辑用各种各样的触发器实现，电路的主要信号、输出信号都是由某个时钟沿驱动触发器产生出来的。 *同步时序电路只在始终上升沿工作可以很好的避免毛刺* ，布局布线后仿真，和用逻辑分析仪采样实际工作信号都没有毛刺。

 是否时序电路一定比异步电路使用更多的资源呢？从单纯的ASCI设计来看，大约需要7个门来实现一个D触发器，而一个门即可实现一个2输入与非门，所以一般来说， *同步时序电路比异步电路占用更大的面积* 。（FPGA/CPLD中不同，主要是因为单元块的计算方式）

 如何实现同步时序电路的延时？ *异步电路产生延时的一般方法是插入一个Buffer、两级与非门等* ，这种延时调整手段是不适用同步时序设计思想的。首先要明确一点HDL语法中的延时控制语法，是行为级的代码描述，常用于仿真测试激励，但是在电路综合是会被忽略，并不能启动延时作用

*** 乒乓操作

 “ 乒乓操作 ” 是一个常常应用于数据流控制的处理技巧，乒乓操作的处理流程为：输入数据流通过 “ 输入数据选择单元 ” 将数据流等时分配到 *两个数据缓冲区* ，数据缓冲模块可以为任何存储模块，比较常用的存储单元为双口 RAM(DPRAM) 、单口 RAM(SPRAM) 、 FIFO 等。

 在第一个缓冲周期，将输入的数据流缓存到 “ 数据缓冲模块 1” ；在第 2 个缓冲周期，通过 “ 输入数据选择单元 ” 的切换，将输入的数据流缓存到 “ 数据缓冲模块 2” ，同时将 “ 数据缓冲模块 1” 缓存的第 1 个周期数据通过 “ 输入数据选择单元 ” 的选择，送到 “ 数据流运算处理模块 ” 进行运算处理；在第 3 个缓冲周期通过 “ 输入数据选择单元 ” 的再次切换，将输入的数据流缓存到 “ 数据缓冲模块 1” ，同时将 “ 数据缓冲模块 2” 缓存的第 2 个周期的数据通过 “ 输入数据选择单元 ” 切换，送到 “ 数据流运算处理模块 ” 进行运算处理。如此循环。

*** 串并转换设计技巧

 串并转换是 FPGA 设计的一个重要技巧，它是数据流处理的常用手段，也是面积与速度互换思想的直接体现。串并转换的实现方法多种多样，根据数据的排序和数量的要求，可以选用寄存器、 RAM 等实现。

 前面在乒乓操作的图例中，就是通过 DPRAM 实现了数据流的串并转换，而且由于使用了 DPRAM ，数据的缓冲区可以开得很大，对于数量比较小的设计可以采用寄存器完成串并转换。如无特殊需求， *应该用同步时序设计完成串并之间的转换* 。比如数据从串行到并行，数据排列顺序是高位在前，可以用下面的编码实现：prl_temp<={prl_temp,srl_in}。

 其中， prl_temp 是并行输出缓存寄存器， srl_in 是串行数据输入。对于排列顺序有规定的串并转换，可以用 case 语句判断实现。对于复杂的串并转换，还可以用状态机实现。串并转换的方法比较简单，在此不必赘述

*** 流水线操作设计思想

 首先需要声明的是，这里所讲述的流水线是指一种处理流程和顺序操作的设计思想，并非 FPGA 、 ASIC 设计中优化时序所用的 “Pipelining” 。

 流水线处理是高速设计中的一个常用设计手段。如果某个设计的处理流程分为若干步骤，而且整个数据处理是 *“ 单流向 ”*  的，即没有反馈或者迭代运算，前一个步骤的输出是下一个步骤的输入，则可以考虑采用流水线设计方法来提高系统的工作频率。

 基本结构为：将适当划分的 n 个操作步骤单流向串联起来。流水线操作的最大特点和要求是，数据流在各个步骤的处理从时间上看是连续的，如果将每个操作步骤简化假设为通过一个 D 触发器 ( 就是用寄存器打一个节拍 ) ，那么流水线操作就类似一个移位寄存器组，数据流依次流经 D 触发器，完成每个步骤的操作

*** 数据接口的同步方法

 数据接口的同步是 FPGA/CPLD 设计的一个常见问题，也是一个重点和难点，很多设计不稳定都是源于数据接口的同步有问题。在电路图设计阶段，一些工程师手工加入 BUFT 或者非门调整数据延迟，从而保证本级模块的时钟对上级模块数据的建立、保持时间要求。

 还有一些工程师为了有稳定的采样，生成了很多相差 90 度的时钟信号， *时而用正沿打一下数据，时而用负沿打一下数据* ，用以调整数据的采样位置。这两种做法都十分不可取，因为一旦芯片更新换代或者移植到其它芯片组的芯片上，采样实现必须重新设计。而且，这两种做法造成电路实现的余量不够，一旦外界条件变换 ( 比如温度升高 ) ，采样时序就有可能完全紊乱，造成电路瘫痪。

 设计数据接口同步是否需要添加约束？建议最好添加适当的约束，特别是对于高速设计，一定要对周期、建立、保持时间等添加相应的约束。这里附加约束的作用有两点：提高设计的工作频率，满足接口数据同步要求；获得正确的时序分析报告

 数据接口的同步是 FPGA/CPLD 设计的一个常见问题，也是一个重点和难点，很多设计不稳定都是源于数据接口的同步有问题。 在电路图设计阶段，一些工程师手工加入 BUFT 或者非门调整数据延迟，从而保证本级模块的时钟对上级模块数据的建立、保持时间要求。

 还有一些工程师为了有稳定的采样，生成了很多相差 90 度的时钟信号，时而用正沿打一下数据，时而用负沿打一下数据，用以调整数据的采样位置。这两种做法都十分不可取，因为一旦芯片更新换代或者移植到其它芯片 组的芯片上，采样实现必须从新设计。而且，这两种做法造成电路实现的余量不够，一旦外界条件变换 ( 比如温度升高 ) ，采样时序就有可能完全紊乱，造成电路瘫痪。

 下面简单介绍几种不同情况下数据接口的同步方法：

 1. 输入、输出的延时 ( 芯片间、 PCB 布线、一些驱动接口元件的延时等 ) 不可测，或者有可能变动的条件下，如何完成数据同步？

 对于数据的延迟不可测或变动，就需要建立同步机制，可以用一个同步使能或同步指示信号。另外，使数据通过 RAM 或者 FIFO 的存取，也可以达到数据同步目的。

 把数据存放在 RAM 或 FIFO 的方法如下：将上级芯片提供的数据随路时钟作为写信号，将数据写入 RAM 或者 FIFO ，然后使用本级的采样时钟 ( 一般是数据处理的主时钟 ) 将数据读出来即可。这种做法的关键是数据写入 RAM 或者 FIFO 要可靠，如果使用同步 RAM 或者 FIFO ，就要求应该有一个与数据相对延迟关系固定的随路指示信号，这个信号可以是数据的有效指示，也可以是上级模块将数据打出来的时钟。对于慢速数据，也可以采 样异步 RAM 或者 FIFO ，但是不推荐这种做法。

 数据是有固定格式安排的，很多重要信息在数据的起始位置，这种情况在通信系统中非常普遍。通讯系统中，很多数据是按照 “ 帧 ” 组织的。而由于整个系统对时钟要求很高，常常专门设计一块时钟板完成高精度时钟的产生与驱动。而数据又是有起始位置的，如何完成数据的同步，并发现数据的 “ 头 ” 呢？

 数据的同步方法完全可以采用上面的方法，采用同步指示信号，或者使用 RAM 、 FIFO 缓存一下。找到数据头的方法有两种，第一种很简单，随路传输一个数据起始位置的指示信号即可，对于有些系统，特别是异步系统，则常常在数据中插入一段同步 码 ( 比如训练序列 ) ，接收端通过状态机检测到同步码后就能发现数据的 “ 头 ” 了，这种做法叫做 “ 盲检测 ” 。

 上级数据和本级时钟是异步的，也就是说上级芯片或模块和本级芯片或模块的时钟是异步时钟域的。

 前面在输入数据同步化中已经简单介绍了一个原则：如果输入数据的节拍和本级芯片的处理时钟同频，可以直接用本级芯片的主时钟对输入数据寄存器采样， 完成输入数据的同步化；如果输入数据和本级芯片的处理时钟是异步的，特别是频率不匹配的时候，则只有用处理时钟对输入数据做两次寄存器采样，才能完成输入 数据的同步化。需要说明的是，用寄存器对异步时钟域的数据进行两次采样，其作用是有效防止亚稳态 ( 数据状态不稳定 ) 的传播，使后级电路处理的数据都是有效电平。但是这种做法并不能保证两级寄存器采样后的数据是正确的电平，这种方式处理一般都会产生一定数量的错误电平数 据。所以仅仅适用于对少量错误不敏感的功能单元。

 为了避免异步时钟域产生错误的采样电平，一般使用 RAM 、 FIFO 缓存的方法完成异步时钟域的数据转换。最常用的缓存单元是 DPRAM ，在输入端口使用上级时钟写数据，在输出端口使用本级时钟读数据，这样就非常方便的完成了异步时钟域之间的数据交换。

 2. 设计数据接口同步是否需要添加约束？

 建议最好添加适当的约束，特别是对于高速设计，一定要对周期、建立、保持时间等添加相应的约束。

 这里附加约束的作用有两点：

 a. 提高设计的工作频率，满足接口数据同步要求。通过附加周期、建立时间、保持时间等约束可以控制逻辑的综合、映射、布局和布线，以减小逻辑和布线延时，从而 提高工作频率，满足接口数据同步要求。

 b. 获得正确的时序分析报告。几乎所有的 FPGA 设计平台都包含静态时序分析工具，利用这类工具可以获得映射或布局布线后的时序分析报告，从而对设计的性能做出评估。静态时序分析工具以约束作为判断时序 是否满足设计要求的标准，因此要求设计者正确输入约束，以便静态时序分析工具输出正确的时序分析报告。

 Xilinx 和数据接口相关的常用约束有 Period 、 OFFSET_IN_BEFORE 、 OFFSET_IN_AFTER 、 OFFSET_OUT_BEFORE 和 OFFSET_OUT_AFTER 等； Altera 与数据接口相关的常用约束有 Period 、 tsu 、 tH 、 tco 等。

** DONE 时序分析
   CLOSED: [2020-08-26 Wed 21:32]

*** DONE HDL时序计算
   CLOSED: [2020-07-02 Thu 17:21]

 <2020-05-09 Sat>

**** 基本概念

 https://blog.csdn.net/u012176730/article/details/54412323
 - 时序余量
 时序余量也称为时间余量，是 *数据到达时间点* 与 *数据建立时间点* 的差，
 或者，是 *数据到达时间点* 与 *数据保持结束时间点* 的差。

 如果数据在数据建立之前到达，寄存器建立。如果新的数据在数据保持结束之后达到，数据就有足够的稳定时间，寄存器能够锁存数据。
 所以时序余量的正负值和数据的稳定性有直接关系

 时序余量的大小和组合逻辑的长度（数据到达时间）相关

 b 建立时间 h保持时间 x数据存在时间（和clk周期相等）

 __________----------__________----------__________
                          bbbbbhhh

              xxxxxxxxxxxxxxxxxxxx 数据长，浪费了时间：考虑缩小周期

 最优的clk周期，就是建立时间+保持时间

 d 组合逻辑传输延迟

 ____----____|----____----
        bbbbb|hhh

     dddxxxxx|xxx  数据到达的时间刚刚好：时间余量为0

      xxxxxxx|x    数据到达早:建立时间余量为负

          xxx|xxxxx数据到达晚：保持时间余量为正

**** 运算关系

 时序余量 + 建立保持时间 = 最小周期 = 最大频率的倒数

*** 静态时序分析

 https://blog.csdn.net/iamsarah/article/details/76979655
 静态时序分析是检查IC系统时序是否满足要求的主要手段。
 以往时序的验证依赖于仿真，采用动态仿真的方法，覆盖率跟所施加的激励有关，有些时序违例会被忽略。此外，仿真方法效率非常的低，会大大延长产品的开发周期。
 静态时序分析工具很好地解决了这两个问题。它不需要激励向量，可以报出芯片中 *所有的时序违例* ，并且速度很快。

 通过静态时序分析，可以检查设计中的关键路径分布；检查电路中的路径延时是否会导致setup违例；检查电路中是否由于时钟偏移过大导致hold违例；检查时钟树的偏移和延时等情况。

 此外静态时序分析工具还可以与信号完整性工具结合在一起分析串扰问题。常用的静态时序工具是PrimeTime。

***** 静态时序分析过程

 1. 将电路分解为时序路径，即将电路转换为时序路径的集合。
    时序路径是一个点到点的数据通路，数据沿着时序路径进行传递。它的起点是输入端口或者寄存器的时钟，终点是输出端口或者一个寄存器的输入引脚，每个路径最多只能穿过一个寄存器。
    这样时序路径就可以划分为：输入端口到寄存器、寄存器到寄存器、寄存器到输出端口、输入端口到输出端口
 2. 计算每个路径上面的延时。 延时一般定义为从输入跳变的50%时刻到输出跳变的50%之间的时间
    在一个路径上，可能包含这几类延时：连线延时（布局布线前后的延时计算方法不一样）、组合逻辑的单位延时（影响因子有输入信号的转换时间，该值也决定输入晶体管的翻转速度、负载、单元本身的固有延时、制程、电压、温度等）、寄存器从clk端到Q端的延时。
    一个路径上的延时是该路径上所有连线的延时与单位延时的总合。
    该延时决定了最大工作频率。
 3. 检查关键路径时序约束是否满足。
    路径约束主要指的是建立时间约束和保持时间约束。在寄存器的综合库描述中对寄存器的D端定义了建立时间和保持时间的约束。
    所谓建立时间约束是指在采样时钟到达之前，数据应该稳定的时间；保持时间是指在时钟到达之后，数据应该保持的时间，这样才能保证寄存器正确地锁存数据。
    时钟对于时序电路至关重要。在进行RTL设计时，可以认为时钟是理想的，但在静态时序分析的时候，必须考虑到实际的时钟情形。时钟模型的精度直接影响了静态时序分析的精度。时钟的非理想性包括：
    1）时钟偏移（clock skew):同一时钟原到达不同的寄存器的延时不同。
    2）时钟抖动（clock jitter）:时钟频率和相位会不断变化，脉冲宽度会发生变化。

    对于纯组合逻辑，时序分析主要检查最大延时约束和最小延时路径。这种情况比较简单。

***** 静态时序分析脚本构造的大致过程：

 1）读入设计的相关信息：链接库、网表，如果是PR之后的静态时序分析还需要读入寄生参数信息

 2）设置驱动及负载

 3）设置时钟

 4）设置建立时间和保持时间

 5）设置设计规则约束：最大负载、最大转换时间等

 6）分析时序：用report_timing  等检查时序，用report_constraint 检查是否有违例。

** DONE book: 高性能FPGA系统--时序设计与分析
   CLOSED: [2020-07-18 周六 12:03] DEADLINE: <2020-07-22 周三 11:00>
   :LOGBOOK:
   CLOCK: [2020-07-16 周四 09:35]--[2020-07-16 周四 09:38] =>  0:03
   CLOCK: [2020-07-16 周四 09:20]--[2020-07-16 周四 09:33] =>  0:13
   CLOCK: [2020-07-16 周四 08:36]--[2020-07-16 周四 08:44] =>  0:08
   :END:

*** terms

 - VLSI:超大规模集成电路(Very Large Scale Integration)

*** DONE FPGA设计流程
    CLOSED: [2020-07-16 周四 21:02]
     :LOGBOOK:
     CLOCK: [2020-07-16 周四 08:44]--[2020-07-16 周四 09:20] =>  0:36
     :END:
 该部分内容可以帮助分析AIPre项目的架构，查漏补缺，方便在面试时进行交流。

 - 需求定义阶段
   定义并完善高层次工程师项目的详细功能和性能需求，完成系统的功能说明
 - 系统设计阶段
   选择功能实现技术；
   选择期间厂商、型号和开发工具；
   定义系统架构，考虑设计实现的可升级性；
   分割固有功能模块与可编程模块；
   定义设计模块功能和接口
 - 实现阶段
   实现整个设计，设计输入、复查、约束、整合；
   初始设计仿真、时序验证、报告分析；
 - 验证阶段
   设计测试、时序验证、设计重构；
   产生下载到目标板的配置文件；
   在目标板上调试和验证功能；
   使用基于FPGA的嵌入式逻辑分析仪测试功能

**** 对实现阶段的各步骤进行更加详细说明

 1. 设计输入
    选择HDL语言或者原理图输入。
 2. 功能仿真
    也称 *前仿真* ， 主要验证HDL的正确性，没有延迟信息。
    testbench + 波形图。
 3. 逻辑综合
    将HDL编译成门电路、RAM、触发器等逻辑单元，并生成网表。
    根据FPGA制造商的库，把逻辑单元转换为具体的门级结构。
 4. 综合后仿真
    把门延时反标注到综合仿真模型中，不能估计线延时。
 5. 映射与布局布线
    把逻辑实现到FPGA的资源中
    - 映射： 对逻辑功能合理分割，并申请可编程资源
    - 布局： 将可编程资源合理布置到芯片内部的固有硬件结构上
    - 布线： 连接拓扑结构
 6. 时序仿真
    也称 *后仿真* ，主要检测是否有时序违规（建立时间保持时间）。
    将布局布线的延时信息反标注到设计网表中，可以反映芯片的实际工作情况。
 7. 静态时序分析
    传统上使用动态仿真，但不能保证测试覆盖率，仿真时间大。
    静态时序分析是，设计者提出特定的时序要求，对FPGA布局布线后的门级电路进行时序分析，检查设计中的路径的时序，以满足设计要求。
    静态时序分析不需要测试向量，时间短；但不能验证功能，也不能测试异步电路。
 8. 时序仿真和功能仿真
    时序仿真：测试异步电路
    功能仿真：功能验证

*** DONE 时序参数和时序路径
    CLOSED: [2020-07-30 周四 16:48] DEADLINE: <2020-07-21 周二 21:00>
     :LOGBOOK:
     CLOCK: [2020-07-16 周四 10:48]--[2020-07-16 周四 10:49] =>  0:01
     CLOCK: [2020-07-16 周四 09:38]--[2020-07-16 周四 10:40] =>  1:02
     :END:
 这一部分属于概念解释，在后面遇到时进行补充

**** 锁存器和触发器

     都可以用作存储器件；
     1. 锁存器：CLK电平敏感（EN端口）， *只会出现* 在组合逻辑中。
       时钟接到锁存控制端口，即可在时钟高电平激活传输，在低电平锁存。锁存器在数据未锁存时（跟随状态），输出端的信号随输入信号变化，就像信号通过一个缓冲器；一旦锁存信号有效，则数据被锁存（保持状态），输入信号不起作用。
       缺点是：不能过滤毛刺，不适用于计数器、存储器等毛刺敏感电路；在FPGA中实现需要更多资源；静态时序分析不能分析。

       数电扩展：和RS锁存器不是同一个概念，因为SR锁存器不可能只和一个输入有关，时钟信号也不能当作锁存控制信号。可通过以下设置使得RS锁存器和FPGA重的宿存器行为一致。
       / 将R和S分别与CLK与之后再连入锁存器，即可实现CLK当作锁存控制信号； 将R反向之后连入S，即可只用一个信号控制，并且不会出现R和S都为1的情况。 /
       和CMOS锁存器的概念相同，即一个传输管和两个并联反向器的结构
     2. 触发器：CLK边沿敏感，只会出现在时序电路中。
        SR触发器是两级SR锁存器，但FPGA中没有SR锁存器单元，FPGA触发器是级联主从锁存器（两个CMOS反向器构成的，两个时钟控制三态门分别在D输入和Q反馈上）。
     3. FPGA中用触发器生成锁存器
        有些FPGA中的存储器可以配制成触发器也可以配制成锁存器，但这并不是都能实现的。
        大多还需要FF->Datch，在CLK的上升沿时，锁存器工作在锁存状态，输出由FF输出决定；在CLK的下降沿，锁存器工作在透明状态，输入直接输出。所以需要一个MUX

***** 避免锁存器
从RTL的角度出发，综合出锁存器完全是无意识的，即if else缺少了else，导致综合时认为信号不变，符合锁存器的性质，才导致错误。

1. 常规的解决方法，就是在组合逻辑中，使用完整的if else和case default。

   但是，以上方法不完备，需要从更深的角度来理解这个现象。我把这个现象归纳为组合逻辑中的反馈。不管是隐式的，还是显式的。

   在组合逻辑中，always @(* ) a=a; a=a+1; 或者 assign a=a+1; a=sel?a:a+1;，这些都是有反馈回路的，是错误的无法综合的。
   a=a+1会出现严重错误，绝不可能通过编译，a=a由于和锁存器相同，被综合锁存器可以通过综合这一步，但是和预期不同。

   严格来说，if sel data = data_in;当sel不为1，data也是有严格的结果，是1或者0，不是继续之前的状态，所以只要RTL中写明白了所有的状态中没有反馈a=a，即可。要求if else完整，仅仅是去掉了默认状态综合出锁存器的情况 else a=a 一样锁存。

2. 还有一种情况是always @ (a or b)结果只对a赋值没有对b赋值，也是隐式生成锁存器。

3. 一种最不容易被发现的就是异步reset生成锁存器
   尽管是放在always @ (posedge clk or negedge rst_n)中，但reset_data只在这个复位时被赋值，其他时间没有用到没有每个时钟上升沿改变，就锁定了。

   解决方法是：
   - reset_data赋值为是固定值；
   - reset_data在复位时被赋值并且仅仅赋值一次（确实是锁存器，功能是复位计数器），那么就应该把该代码单独拿出来生成锁存器，不应该放在一起;
   - 不使用异步reset，仅always @ (posedge clk)

***** 锁存器的作用
锁存器问题很多，但保留锁存器可以保证FPGA的灵活性。
- 地址锁存：多处理器的接口就需要一个Latch来缓存数据或地址
- 锁存器比Flip-Flop快很多
**** 建立时间和保持时间

     建立时间是时钟上升沿到来之前数据输入必须保持稳定的时间；
     保持时间是时钟上升沿到来之后数据输入必须保持稳定的时间。
     其根本原因在于亚稳态的恢复稳定的时间要远大于数据传输延时，从而导致输出不确定。
     1. 建立时间
        在时钟0--1时，主锁存器的传输门关闭，从锁存器的传输门打开。外部的数据会被隔断，保存在主锁存中的数据会传输到从锁存器中，这一段的数据必须保持不变。关门时间点的从传输门信号，从时间轴上看，就是建立时间之前的信号。如果数据发生变化，反馈回路就会发生震荡，导致输出不稳定。建立时间就是主锁存器的传输延迟和反馈延迟。
     2. 保持时间
        在时钟1时，在主锁存器传输门关闭的时间内，外部数据也不能变化。保持时间就是关门时间。

**** 时钟抖动和时钟偏移

 时钟抖动是时钟的周期发生变化；时钟偏移是时钟的延时发生变化。

**** 时序路径

 静态时序分析就是对所有的时序路径进行分析。

*** DONE 性能估计
    CLOSED: [2020-08-27 Thu 16:45]

 预估时序性能：50/50准则，认为，设计的逻辑延迟与布线延迟相等，因此一级延迟是2*Tlogic。
 Tlogic = Tilo + Tckdi + Tsu这些都是可以在FPGA手册中查到的。

*** DONE 时序分析
    CLOSED: [2020-08-29 Sat 09:35] SCHEDULED: <2020-08-27 Thu 19:30>
     :LOGBOOK:
     CLOCK: [2020-07-17 周五 09:27]--[2020-07-17 周五 09:32] =>  0:05
     :END:
 综合工具根据代码风格决定如何优化硬件架构

** DONE SERDES 串行/解串行，串并接口电路
   CLOSED: [2020-08-26 Wed 21:32]

 并行传输技术的发展受到了时序同步困难、信号偏移严重，抗干扰能力弱以及设计复杂度高等一系列问题的阻碍。
 与并行传输技术相比，串行传输技术的引脚数量少、扩展能力强、采用点对点的连接方式，而且能提供比并行传输更高带宽，因此现已广泛用于嵌入式高速传输领域。

 SERDES是串并接口电路，点对点单向传输，采用自同步差分信号传输。SerDes不传送时钟信号，SerDes在接收端集成了CDR(Clock Data Recovery)电路，利用CDR从数据的边沿信息中抽取时钟，并找到最优的采样位置。
  SerDes需要参考时钟(Reference Clock)，接收端Rx和发送端Tx的参考时钟可以允许几百个ppm的频差(plesio-synchronous system)，也可以是同频的时钟，但是对相位差没有要求

*** 架构

 SERDES内部包括高速串并转换电路、时钟数据恢复电路、数据编解码电路、时钟纠正和通道绑定电路，
 为各种高速串行数据传输协议提供了 *物理层基础* 。
 TX发送端和RX接收端功能独立，而且均由物理媒介适配层（Physical Media Attachment，PMA）和物理编码子层（Physical Coding Sublayer，PCS）两个子层组成。

 - PMA子层
   内部集成了高速串并转换电路，预加重电路、接收均衡电路、时钟发生电路和时钟恢复电路。
   串并转换电路的作用是把FPGA内部的并行数据转化为MGT接口的串行数据。
   预加重电路是对物理连接系统中的高频部分进行补偿，在发送端增加一个高通滤波器来放大信号中的高频分量进而提高信号质量，但预加重电路会导致功耗和电磁兼容（Electro Magnetic Compatibility，EMC）增加，所以如非必要一般情况下都把它屏蔽掉。
   接收均衡电路主要用来补偿由频率不同引起的阻抗差异。
   时钟发生电路与时钟恢复电路在发送端把时钟和数据绑定后发送，在接收端再从接收到的数据流中恢复出时钟，这样可以有效地避免在高速串行传输的条件下时钟与数据分开传输带来的时钟抖动问题。
 - PCS子层
   内部集成了8B/10B编/解码电路、弹性缓冲电路、通道绑定电路和时钟修正电路。
   8B/10B编/解码电路可以有效的避免数据流中出现连续的‘0’或者‘1’，以保证数据传输的平衡性。
   通道绑定电路的作用是通过在发送数据流中加入K码字符，把多个物理上独立的MGT通道绑定成一个时序逻辑上同步的并行通道进而提高传输的吞吐率。
   弹性缓冲电路用来解决恢复的时钟与本地时钟不一致的问题并可以通过对缓冲区中的K码进行匹配对齐来实现通道绑定功能。

*** 工作逻辑
**** 发送

 发送缓冲 --> 8B/10B --> 串并转换 --> 预加重 --> 发送均衡

**** 接收

 接收均衡 --> 并串转换 --> 时钟校准与通道绑定 --> 8B/10B --> 接收缓冲

**** 数据路径图

 [[./refile/figures/SERDES-structure.png]]

*** 串转并：多重相位技术

 如果输入的串行数据流比特率为x， 那么可以使用多重相位以x/4的低速时钟来重新组织数据流。
 输入的数据流直接连接到4个触发器，每一个触发器运行在时钟的不同相位上（0、90、180以及270），分别采集高速时钟的一个clk的信号。

 注意： 相位等差排列，时钟频率严格等于输入数据流速率的1/4。怎样才能实现呢？
 我们必须和输入的数据流保持锁定。我们可以使用典型的锁相环来实现这一点，但是锁相环需要一个全速率的时钟，这是很难满足的。
 锁相环是高速SERDES设计中最重大的改进之一，它主要用于时钟和数据恢复。一般的锁相环需要有运行在数据速率上的时钟，不过可以通过多种技术来避免这种要求，包括分数鉴相器、多重相位锁相环、并行采样以及过采样数据恢复。

*** 8B/10B 编码

 这种编码方式，带来了巨大的编码开销：为了获得2.5Gbit的带宽，需要3.125Gb/s的线路速率

 输入的原始数据转变成接收器可以接收的格式，并保证有足够的切换提供给时钟恢复电路。编码器还提供一种将数据对齐到字的方法。同时线路可以保持良好的直流平衡。
 线路编码机制主要有两种方式，分别为数值查找机制8B/10B和扰码机制。

**** 编码符号

 8B/10B可将8位的字转化为10位符号。这些符号可以保证有足够的跳变用于时钟恢复，保证直流平衡。
 一个符号有6个0和4个1，这种情况称为正运行不一致符号，简写为RD+，
 另一个符号则有4个0和6个1，这种情况称为负运行不一致符号，简写为RD-。
 编码器会检测0和1的数量，并根据需求选择下一个符号，以保证线路的直流平衡。

**** comma对齐

 接收器在输入数据流中扫描搜寻特定的比特序列（以太网中使用K28.5）。
 如果找到序列，解串器调整字符边界以匹配检测到的Comma字符序列。扫描是连续进行的，一旦对齐确定，所有后续的Comma字符均会发现对齐已经确定。

*** 通道绑定

 有时候我们需要传送的数据会超过一条串行链路的承载能力。在这种情况下，可以同时使用多条链路来并行传输数据。
 如果使用这种方式，则输入的数据流必须是对齐的。这个过程通常称作通道绑定。
 通道绑定可以吸收两个或多个MGT之间的偏差，将数据提交给用户，就像只使用一条链路进行传送一样。

*** 预加重

 因为在传输过程中高频信号衰减严重，可以在发射端进行高频信号放大，使得接收端的高频信号和低频信号基本平衡。

 但该技术使用不当会造成严重的电路干扰。

** DONE 串并转换
   CLOSED: [2020-07-20 周一 09:28]

*** 移位寄存器实现

串入并出：连续输入单bit的数据，进行移位，凑够n位后输出；
并入串出：输入的是n bit的数据，进行移位，末位输出；

#+begin_src verilog
module shifter_s1p16(			//串行右移转并行输出
	input clk,
	input reset_n,
	input serial_in,
	output reg [15:0] parallel_out
);

	always@(posedge clk or negedge reset_n)
		if(!reset_n)
			parallel_out <= 0;
		else
			parallel_out <= {serial_in, parallel_out[15:1]}; // 拼接操作实现移位寄存器

endmodule

module p2s (     //8bit并行移位输出
  input [7:0] pdin,
  output	reg sdout,
  input	      en,
  input	      clk,
  input	      rstn
);
reg [6:0] 		tmp;		// 共7bit

always @ ( posedge clk or negedge rstn )
  if ( !rstn )
    {tmp, sdout} <= 0;
  else
    {tmp[4:0], sdout} <= {'b0, tmp[4:0]};
#+end_src

*** 用计数器实现

data_out <= data[cnt]; //cnt为计数器

data_out[cnt] <= data_in;

*** [[*串转并：多重相位技术][串转并：多重相位技术]]
** DONE SOPC, 动态重构， 虚拟化
   CLOSED: [2020-08-26 Wed 21:32]
   :LOGBOOK:
   CLOCK: [2020-07-16 周四 09:33]--[2020-07-16 周四 09:35] =>  0:02
   :END:
 [2020-07-16 周四 09:33]
 [[file:g:/CHxin/NutCloud/orgible/inbox.org::*book: 高性能FPGA系统--时序设计与分析][book: 高性能FPGA系统--时序设计与分析]] 第一章第二节
 动态重构技术可以参考 ‘book：可重构计算’ 第五章

 静态重构：在计算之前对数据通路进行功能重构。时间代价大。典型的处理器是细粒度的FPGA
 静态重构的时间：Stratix 5型号为GXA3，配置文件大小为214M，采用串行低配置带宽和并行高配置带宽，对FPGA进行重构的时间分别为0.534s和0.067s。

 动态重构：在计算过程中对数据通路进行功能重构。典型的处理器是粗粒度的CGRA（可重构阵列），配置信息量小。

 静态和动态重构的主要区别：配置进行时非配置区域的工作状态，需要停下来等待，则认为是静态，如果其他区域不被打断，则具备动态。

 部分重构：数据通路在空间上被划分为多个区域，每个区域可以被重构为不同的功能，而不会影响到其他区域的当前状态。
** DONE PCIe and NVMe
   CLOSED: [2020-07-19 周日 21:39] SCHEDULED: <2020-07-18 Sat 9:00>
   :LOGBOOK:
   CLOCK: [2020-07-02 Thu 21:43]--[2020-07-02 Thu 22:17] =>  0:34
   :END:
 [2020-07-02 Thu 21:43]

 可以参考book: altera IP核关于PCIe的部分

*** TODO PCIe

 https://zhuanlan.zhihu.com/p/26172972
 https://zhuanlan.zhihu.com/p/26244141
 https://cloud.tencent.com/developer/article/1458755

 PCIe 是一种差分信号串行通信协议，可以工作在非常高的频率下。pcie数据的传输方式类似于TCP/IP的方式，可以将架构分为物理层，链路层，传输层，然后将数据按数据包的格式进行传输。

 PCI总线和设备树是X86硬件体系内很重要的组成部分，几乎所有的 *外围硬件* 都以这样或那样的形式连接到PCI设备树上。虽然Intel为了方便各种IP的接入而提出IOSF总线，但是其主体接口(primary interface)还依然是PCIe形式。
 PCIE允许每个总线上最多存在 *32个Device* 。

 扩展槽用于扩充计算机功能。现在最常见的扩展槽是PCIe插槽，实际上在你看不见的计算机主板芯片内部，各种硬件控制模块大部分也是以PCIe设备的形式挂载到了一颗或者几颗PCI/PCIe设备树上。固件和操作系统正是通过枚举设备树们才能发现绝大多数即插即用（PNP）设备的。

**** 扩展接口

 作为扩展接口，它主要用于外围设备的连接和扩展，而外围设备吞吐速度的提高，往往会倒推接口速度的提升。
 - 第一代ISA插槽出现在第一代IBM PC XT机型上（1981），作为现代PC的盘古之作，8位的ISA提供了4.77MB/s的带宽（或传输率）。到了1984年，IBM就在PC AT上将带宽提高了几乎一倍，16位ISA第二代提供了8MB/s的传输率。
 - 真正的高速总线始于VLB，它绑定自己的频率到了当时486 CPU内部总线频率：33MHz。而到了奔腾时代，内部总线提高到了66MHz，给VLB带来了严重的兼容问题，造成致命一击。
 - Intel在1992年提出PCI（Peripheral Component Interconnect）总线协议， PCI总线标准初试啼声就提供了133MB/s的带宽(33MHz时钟，每时钟传送32bit)
 - AGP被发明出来专门连接北桥与显卡，而为服务器则提出PCI-X来连接高速设备。
 - 2004年，Intel再一次带领小伙伴革了PCI的命。PCI express诞生了，其后又经历了两代，现在是第三代(gen3，3.0)，gen4有望在2017年公布，而gen5已经开始起草中。

**** PCI标准
***** 特点

 - 它是个并行总线。在一个时钟周期内32个bit（后扩展到64）同时被传输
 - PCI空间与处理器空间隔离。PCI设备具有独立的地址空间，即PCI总线地址空间，该空间与存储器地址空间通过Host bridge隔离。处理器需要通过Host bridge才能访问PCI设备，而PCI设备需要通过Host bridge才能主存储器。在Host bridge中含有许多缓冲，这些缓冲使得处理器总线与PCI总线工作在各自的时钟频率中，彼此互不干扰。Host bridge的存在也使得PCI设备和处理器可以方便地共享主存储器资源。处理器访问PCI设备时，必须通过Host bridge进行地址转换；而PCI设备访问主存储器时，也需要通过Host bridge进行地址转换。
 - 扩展性强。PCI总线具有很强的扩展性。在PCI总线中，Root Bridge可以直接连出一条PCI总线，这条总线也是该Root bridge所管理的第一条PCI总线，该总线还可以通过PCI桥扩展出一系列PCI总线，并以Root bridge为根节点，形成1颗PCI总线树。在同一条PCI总线上的设备间可以直接通信，并不会影响其他PCI总线上设备间的数据通信。隶属于同一颗PCI总线树上的PCI设备，也可以直接通信，但是需要通过PCI桥进行数据转发

**** PCIe标准

 PCIe和PCI最大的改变是由并行改为串行，通过使用差分信号传输（differential transmission），好处是提高传输频率，半双工变为全双工。

***** 和PCI的不同

 - PCI是总线结构，而PCIe是点对点结构
 - PCIe支持热插拔，PCI不支持。
 - PCIe的连线是由不同的lane来连接的，这些lane可以合在一起提供更高的带宽
 - PCI配置空间从256B扩展为4k，同时提供了PCIe memory map访问方式

***** 硬件

  可以将任何PCIe卡插入任何PCIe插槽中！不同gen的速度不同但不影响，以速度低的为准，PCIe在链接training的时候会动态调整出双方都可以接受的宽度。

***** 体系架构

 PCIe的体系架构。下图是一个PCIe的拓扑结构示例。
 PCIe协议支持256个Bus, 每条Bus最多支持32个Device，每个Device最多支持8个Function，所以由BDF（Bus，device，function）构成了每个PCIe设备节点的身份证号。

 PCIe是点对点通信，从root port到 end port。可以通过总线直接相连，也可以通过switch连接多个EP。

 设备：PCIe体系架构一般由root complex，switch，endpoint等类型的PCIe设备组成，在root complex和switch中通常会有一些embeded endpoint(这种设备对外不出PCIe接口)。NVMe、显卡、声卡、网口都是设备；

 桥：当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带。PCIe的Bridge是连接总线与总线的设备。 Bus1 ----- Bridge1 ------- Bus2；

 总线：PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥

****** TODO Switch与Bridge

 一个典型的结构是一个root port和一个endpoint直接组成一个点对点连接对，而Switch可以同时连接几个endpoint。一个root port和一个endpoint对就需要一个单独的PCI bus。而PCI是在同一个总线上的设备共享同一个bus number。

 Switch的概念是在PCI-E时代引入的，其相对于桥最大的一个本质区别就是同一个Bus内部的多个角色之间采用的是Switch交换而不是Bus。

 PCI-X时代真的是使用共享Bus传递数据，这就意味着仲裁，意味着低效率。
 然而，PCI-E保留了PCI-X体系的基本概念，比如依然沿用“Bus”这个词，以及“桥/Bridge”这个词，但是这两个角色都成为了 *虚拟角色* 。
 一个Switch相当于一个虚拟桥+虚拟Bus的集合体，每个虚拟桥（VB）之下只能连接一个端点设备（也就是最终设备/卡，End Point/EP）或者级联另外一个Switch，而不能连接到一个Bus，因为物理Bus已经没了。
 这种Fanout形式依然必须遵循树形结构，因为树形结构最简单，没有环路，不需要考虑复杂路由。

***** 设备枚举过程

 PCIe设备的拓扑结构，是以Root Complex为根节点的树形结构，Host对PCIe设备扫描是采用了深度优先算法，对每一个设备进行编址。这一过程的结果放置在配置空间中。
 从Root Complex出发，寻找设备和桥。发现桥后设置Bus，继续寻找；发现一个PCI设备子树，递归回到上一个Bus。

*** TODO PCIe IP core

 高性能互联协议，用于实现网络适配器、存储网络、嵌入式控制器、图形加速卡以及音视频等。
 提供基于包的串行点到点传输。
 性能可以根据通道数进行设置。

**** 应用层
**** 传输层

 配置空间（管理与应用层的通信）、接收和发送通道、接受缓存、流控制、将PCIe包映射到RX和TX总线。

 包含3个通用模块；发送数据通道、配置空间、接收数据通道。
 可以初始化多个虚拟通道VC，指定虚拟通道优先级。

 1. 接受数据
    - 传输层从数据链路层接收一个TLP
    - 配置空间判断TLP是否正常，并根据负载类型、虚拟通道映射，将包发送到合适的虚拟通道
    - 在每个虚拟通道内，传输层包根据其传输类型，存储在接收缓存的指定部分
    - 传输层包FIFO模块存储缓存的传输包地址
    - 根据需要，接收序列化和重排序模块对等待的包进行整理，从FIFO中取出优先级高的包先传输到应用层
 2. 发送数据
    - 传输层通知应用层对于指定类型的包有充足的流控制信用。应用层可以不用理会这个信息。
    - 应用层请求发送包，提供PCIe传输并准备好在连续的时钟周期内提供完整的数据载荷
    - 传输层验证有充足的流控制信用，确认或推迟发包请求。
    - 应用层向前传递传输层包，传输层在虚拟通道之间进行仲裁，然后将优先传送的包发到数据链路层

**** 数据链路层

 管理包发送和接受、保持链路上的通信质量：CRC、根据ACK/NAK包管理重试缓存和重试机制。

 包含6个模块：数据链路控制和状态管理状态机、电源管理模块、包生成器和检查器、重试缓存器、ACK/NAK包管理器、TX仲裁器

**** 物理层

 初始化链路，传输速度自动协商、通道编号和通道带宽，数据包进行编码解码、数据串行化和解串行化

 物理层通过SERDES接口连接到物理链路

 包含2个子层：MAC层和PHY层，MAC层负责链路控制和状态机、多通道切换功能，PHT层负责8B/10B解码，弹性缓存和串行化/解串行化

*** TODO NVMe

 https://zhuanlan.zhihu.com/p/71932170 一篇文章讲清什么是NVMe

 https://mp.weixin.qq.com/s/2qQpudFsyMRTE0BwuhKENQ 理解NVMe的内部实现原理，这一篇就够了

 https://mp.weixin.qq.com/s/nHWMSUEYXId62mrPmXBMXQ 存储系统设计——NVMe SSD性能影响因素一探究竟

 https://mp.weixin.qq.com/s/mUM7ENQVvCb4Fj-42fUHkw 一篇文章搞懂SSD的里里外外及访问特性

 只有SSD运行在NVMe上。由于SSD本身的物理特性，其数据的访问已经非常快了，连接SSD和CPU的PCIe总线也非常快，性能的瓶颈就是出在PCIe接口与SSD物理介质的传输协议上。

 对与PCI-E来说AHCI可不是一个好的选择，想发挥最佳性能其实需要新的标准——NVMe。
 NVMe(Non-Volatile Memory express)，非易失性内存主机控制器接口规范,是一种建立在M.2接口上的一种标准（或称协议）,是专门为闪存类存储设计的协议，为SSD建立新的存储规范标准。
 NVMe SSD可以很方便的匹配不同的平台、系统，无需厂家提供相应的驱动就可以正常工作。

 NVMe更够速度更高的原因：建立了多个计算机与存储设备的通路（队列）。目前基于SCSI协议的SAS和SATA只能是单个队列而且每个队列的深度也比较低，分别是254和32的队列深度。而NVMe协议设计之初就考虑了该问题，它的队列数量可以是64K(65535个命令队列和1个管理队列)，而每个队列的深度可以高达64K。与SCSI协议相比，就好比一个乡村的羊肠小路和一个双向八车道的高速公路的差别。
 主机和控制器之间通过共享内存的队列实现交互，提交队列和完成队列就是内存的一个区域。NVMe的队列分为2种，其中一种是用于管理的队列，称为Admin Queue(管理队列)，仅有一个，另外一种是命令队列(Command Queue)，最多可以有65535个。其中命令队列的数量和模式都是通过管理队列来设置的。其中每一个队列实际上是一个队列对，也就是包括两个队列，分别是提交队列(Submission Queue)和完成队列(Completion Queue)。提交队列用于主机端向NVMe设备发送NVMe命令，而完成队列则用于NVMe设备向主机反馈命令执行情况。

 虽然PCIe和NVMe密切相关，但两个术语指的是略有不同的技术。可以将PCIe看作是系统的物理部分。当您将一个NVMe SSD插入服务器时，您需要通过一个PCIe插槽连接它。
 相比之下，NVMe是一种协议，是一组允许SSD使用PCIe总线的软硬件标准。可以这么说，NVMe是允许存储设备与服务器连接的语言，而PCIe是实际的物理连接。

*** TODO PCIe & HTTP/IP

 HTTP/IP负责CPU到网卡，PCIe负责外设到CPU。
 PCIe没有IP层

** FPGA应用
参考 Book:FPGA原理与结构 第七章
*** 超级计算机
*** 网络通信
**** 物理层
**** 交换机
路由算法、交换机算法的实现，FPGA实现不占优势
数据帧的解析、处理和转发
1. CAM内容地址存储器
   比较数据来返回地址：交换机中MAC地址与端口的映射
2. 优化数据帧处理过程
   - 跳过CPU，使用FPGA直接在输入和输出或者存储器之间进行处理
   - 或者数据包直接就放在FPGA中缓存中进行处理，不放在交换机的存储中
*** 大数据处理：Web搜索
*** 基因科学：短数据拼接
*** 金融市场：高频交易
*** 人工智能：深度学习
*** 图像处理：
** TODO 时钟
 内部时钟不建议使用，一个是因为产生内部时钟的逻辑是有延时的，导致A_clk产生也会延时,Data与A_clk会有延时,就会有亚稳态的稳压;另外一个就是由触发器生成A_clk的驱动能力问题。

 https://www.cnblogs.com/IClearner/p/6440488.html
*** 多时钟选择
 动态时钟源选择 https://www.cnblogs.com/yfwblog/p/4792708.html
 选择信号，在时钟的上升沿改变，并经过三次寄存器缓存。

 也可以sel1和sel2直接通过非门相连。这样和三级缓存之后信号再非门，有什么区别？
*** 门控时钟
 enable信号，在时钟的下降沿产生

*** 双时钟边沿触发
 一般情况下，我们不建议使用双边沿时钟，这是因为：
   - 由于上下沿都用，要求时钟的质量很高，一般的时钟源很难达到，成本高。
   - 由于时钟的抖动等不确定因素的存在，容易使时钟的占空比发生改变，因此容易引起建立时间和保持时间的违规。
   - 当使用的双沿时钟之后，时钟的约束变得复杂，此外当某处发生违规之后，违规的路径的查找难度比单沿时钟大。
   - 还有一点就是测试难度比较大，双沿电路的测试电路必定有别与单沿的测试电路。进行扫描测试时，上下沿的时钟先都得插入多路复用器进行选择。
*** 时钟约束
 https://zhuanlan.zhihu.com/p/142434428

 create_cloclk、set_clock_uncertainty、set_clock_latency、set_clock_transition分别进行时钟的周期、偏移、延时、转换约束。

**** false path
 FALSE PATH就是我们在进行时序分析时，不希望工具进行分析的那些路径。一般 *不需要工具时序分析的路径* 指的是异步的路径，异步路径就是指的不同时钟域的路径。跨时钟域信号通过寄存器打两拍保持异步信号同步的路径；一上电只写一次的寄存器路径；复位或测试逻辑；异步读写双端口RAM。
 在QuartusII的一个培训文档里面解释了什么时候要用到FALSE PATH：
 1. 从逻辑上考虑，与电路正常工作不相关的那些路径，比如测试逻辑，静态或准静态逻辑。
 2. 从时序上考虑，我们在综合时不需要分析的那些路径，比如 *跨越异步时钟域的路径* 。

 一些情况下，不设置FALSE PATH也可以， *工具会去分析相关时序路径，但是肯定会有setup或者hold不满足* ，这个时候就需要去确认这些路径是否有问题了。
 而设置了FALSE PATH后，就告诉工具不用去分析这些路径了，这样工具就不会报告出来了，另外还有一个好处就是综合布局布线的 *时间会大幅减少* ，因为没有时序问题了，工具就可以跑的很快。
** DONE 老石谈芯
   CLOSED: [2020-09-09 Wed 16:53]
   :LOGBOOK:
   CLOCK: [2020-09-08 Tue 18:23]--[2020-09-08 Tue 18:40] =>  0:17
   CLOCK: [2020-09-07 Mon 14:32]--[2020-09-07 Mon 14:39] =>  0:07
   CLOCK: [2020-09-07 Mon 10:12]--[2020-09-07 Mon 11:24] =>  1:12
   CLOCK: [2020-09-07 Mon 09:20]--[2020-09-07 Mon 10:08] =>  0:48
   :END:
 https://zhuanlan.zhihu.com/c_1071374786155958272
*** 抗辐射宇航级RTAX4000系列FPGA
 在复杂的宇航空间环境下，存在着大量的高能带电粒子，它们会造成集成电路中的电子元件的电位状态的改变，如从“0”变成“1”，或从“1”变成“0”，这种现象叫做单粒子翻转（Single-Event Upsets, SEU）。
 这些微小的数位改变对于数字系统的影响往往是致命的。
 因此，在帕克号的FPGA中集成了抗SEU、外加三重冗余保护（Triple Module Redundancy - TMR）的寄存器，使SEU发生的概率降到了十的十次方分之一。

 FPGA上还有专门的逻辑发现和修正SRAM上发生的位翻转。即使SRAM自带的错误检测和校正电路发生故障，这些SEU也能被发现并修正。

 此外，RTAX4000 FPGA采用了金属对金属的反熔丝结构互联，因此即使受到宇宙离子冲击也不会改变FPGA的逻辑结构。
*** FPGA虚拟化
 现在FPGA是单用户、单任务，无法对FPGA进行充分使用。虚拟化让多个用户的 AI 应用能够同时在一个 FPGA 上高效、可靠、灵活地运行起来。

 1. 使用户能够轻松的在不同时间，对多个FPGA的各类资源进行充分的调度与使用，在不同时刻运行不同的任务。

 2. 将FPGA进行一定程度的逻辑抽象，使顶层用户不必太多关注于FPGA硬件逻辑的实现方式与细节。
**** Overlay
 FPGA Overlay可以说是目前应用最广泛的FPGA虚拟化方法之一，是一层位于FPGA硬件层之上，并连接顶层应用的虚拟可编程架构。

 使用Overlay的主要目的是为上层用户提供一个他们更为熟悉的编程架构与 *接口* ，便于他们通过诸如C语言等高层语言对Overlay中的通用处理器等进行编程，而不需担心具体的硬件电路实现，由此实现了对FPGA底层硬件资源的抽象和虚拟化。

 另外，由于Overlay层提供的逻辑处理单元或软核处理器通常与底层FPGA硬件无关，因此方便了上层设计在不同FPGA架构之间的移植。使用Overlay的另外一个好处是可以在很大程度上缩短FPGA的编译时间。

 Overlay技术与高层次综合（High-Level Synthesis，简称HLS）技术的主要区别在于，前者引入的Overlay层往往并不能完全隐藏底层的FPGA结构，由此可能带来额外的开发难度和成本。

**** 动态可重构
 部分可重构是指，可以将FPGA内部划分出一个或多个区域，并在FPGA运行过程中单独对这些区域进行编程和配置，以改变区域内电路的逻辑，但并不影响FPGA其他电路的正常运行。

 利用部分可重构技术，可以将FPGA划分成若干个子区域，作为虚拟FPGA供单个或多个用户使用，同时保留一部分逻辑资源作为不可重配置区域，用来实现必要的基础架构，如内存管理与网络通信等。一个典型的例子是微软的Catapult项目。在他们2014年ISCA会议上发表的文章中介绍，每个FPGA都在逻辑上被划分成“Role”和“Shell”两部分。

 在一个vFPGA进行动态重构时，其他vFPGA的运行不会受到影。

 为了通过部分重构技术进行FPGA虚拟化，通常都需要引入额外的管理层。

 对FPGA强行划分多个可重构区域，也可能会严重影响系统性能，会严重影响编译时布局布线的灵活度。

**** FPGA资源池
 与其在单一FPGA芯片上使用动态重构技术划分多个可重构区域，也可以使用多个FPGA级联，使每个FPGA负责单个或少量用户，并通过一个整体的虚拟化框架完成系统的集成与资源调度。

 硬件层面，需要实现多FPGA互联，形成FPGA“资源池”，同时也要支持其他硬件结构。

 软件层面，需要有一个虚拟化框架，对用户任务进行有效的FPGA部署。

 服务管理器对整个资源池的FPGA进行管理，实现诸如FPGA负载均衡、互联管理、故障处理等功能。

**** 虚拟化框架
 FPGA数据流优势：在基于数据流的架构中，只需在应用开始时从内存中读取数据，随后会在FPGA上进行数据流处理和计算，所有中间数据不会返回内存，直到计算结束。这样从根本上杜绝了访存的性能瓶颈。

 将数据流图映射到底层的FPGA硬件平台，从而对上层用户虚拟化了底层电路逻辑的具体实现
*** eFPGA
 本质上就是集成在ASIC里的IP核

 FPGA的高性能主要是通过极高的硬件并行处理能力、深度流水线、以及高位宽总线等方式取得，单就运行频率而言并不能和ASIC相比。

 传统的FPGA而言，它主要的“功耗大户”之一是FPGA的可编程I/O部分
*** 数据中心的FPGA
 计算加速、网络传输加速、数据存储加速

 GPU的能耗实在太大，在很大程度上限制了GPU的适用范围

 以太网硬件产品线，形成了传统网卡（ASIC）+智能网卡（FPGA）+网络功能加速卡（FPGA）的完整产品组合

 与基于GPU的方案相比，FPGA最大的优势是低延时的信号处理，这在处理各类车载传感器信号时至关重要。同时，类似于EyeQ，FPGA有着更优的性能功耗比，更适于各类嵌入式AI应用
*** HLS
 FPGA如果想在算法计算领域取得成功，必须把硬件算法设计和底层电路设计分开。做到快速实现目标算法。

 高层次综合（High-level Synthesis）简称HLS，指的是将高层次语言描述的逻辑结构，自动转换成低抽象级语言描述的电路模型的过程。

 高层次语言，通常有着较高的抽象度，并且往往不具有 *时钟或时序的概念* 。相比之下，诸如Verilog、VHDL、SystemVerilog等低层次语言，通常用来描述时钟周期精确（cycle-accurate）的寄存器传输级电路模型。

 1. 一个拥有100万逻辑门的芯片设计通常需要编写30万行RTL代码。因此，完全使用RTL级的逻辑抽象设计当代芯片是不现实的。使用诸如C、C++等高层语言对系统建模，可以将代码密度压缩7到10倍。

 2. 高层语言能促进IP重用的效率。

 3. HLS能帮助软件和算法工程师参与，从而使软件和工程师能专注于上层算法的实现。
    对于硬件工程师而言，HLS也能帮助他们进行快速的设计迭代，并专注于对性能、面积或功耗敏感的模块和子系统的优化设计。

 HLS工具综合生成的结果也有了长足进步，在某些应用领域甚至可以和人工手写RTL近似的性能水平。

 和ASIC设计不同，FPGA有着固定数量的片上逻辑资源。因此 *HLS工具不用过度纠结于ASIC设计中面积、性能和功耗的绝对优化，而只需要将设计合理的映射到FPGA的固定架构上即可* 。这样，HLS就成为了在FPGA上快速实现目标算法的绝佳方式。

 编译器会将高层语言模型转换为中间表达式（IR），并进行一系列针对代码复杂度、冗余、并行性等方面的代码优化。然后再根据具体的硬件平台，综合生成RTL代码、验证与仿真环境，以及必须的时序和布局约束等。

 传统的处理器编译器设计通常只有一个主要目标，那就是尽量提升性能。相比之下，高层次综合工具需要统筹考虑各种电路设计的主要指标，如性能、功耗、面积等等，同时也要兼顾工具本身的性能，比如占用的资源和运行时间等

 循环优化一直是HLS优化方法的研究重点和热点，因为这是将原本顺序执行的高层软件循环有效映射到并行执行的硬件架构的重点环节。

 对于FPGA而言， *内存瓶颈一直是制约系统性能的重要因素* 。除片上的各类BRAM之外，还有各类片外存储单元，如DDR、QDR，以及近年兴起的HBM等等。因此，有效利用片上和片外各类存储单元一直是HLS的研究热点

 业界普遍认为，GPU之所以在人工智能时代取得了非凡成功，很大程度上得益于 *对软件和算法工程师友好的编程语言和环境* 。
 与之相比，FPGA虽然也在不断扩展自己的应用范围，并在性能和功耗上相比GPU有着明显优势，其编程模型还是以硬件工程师进行RTL开发为主。FPGA的高层次综合是业界发展的必然趋势。相信随着HLS领域的难题不断被攻破，使用高层语言对FPGA进行高效编程也必然会实现，而这也将最终成为FPGA更广泛应用的最后一块拼图。
* IC
** DONE 低功耗设计
   CLOSED: [2020-08-10 Mon 15:28]
https://zhuanlan.zhihu.com/p/137937714
加一些时钟门控，模块不用时候可以关掉，组合逻辑计算单元不用的时候避免翻转，乘法器的使能信号的控制，避免无效翻转，数据通路寄存器带着使能打拍，工具也会自动插时钟门控。

DVFS（动态电压频率调整），多阈值电压技术，多电压技术。

1. 动态功耗
   P_d = C * V^2 * f
   想要减少功耗，就要减小负载电容、降低晶体管两端电压、降低信号翻转频率

   如果考虑短路功耗，即两个晶体管在翻转时，一个尚未完全闭合，一个尚未完全打开时流过的电压，需要减小短路电流的持续时间，减小短路电流。目前工艺，短路时间很短，此功耗可以忽略不计。

2. 静态功耗
   静态功耗主要是由漏电流引起的，其功耗为P_s = V * I，应当减少漏电流。
   - 亚阈值漏电流(Sub-threshold Leakage, ISUB）: 应当截止时流过的电流.
   - 栅极漏电流(Gate Leakage, Igate): 由于栅极氧化物隧穿和热载流子注入，从栅极直接通过氧化物流到衬底的电流。
   - 栅极感应漏电流(Gate Induced Drain Leakage, IGIDL): 源或漏扩散区处在与衬底不同电位。结泄漏电流与其他泄漏电流相比时通常都很小。
   - 反向偏置结泄漏(Reverse Bias Junction Leakage ,IREV):由少数载流子漂移和在耗尽区产生电子/空穴对引起。

3. 硬宏功耗
   门控时钟：https://zhuanlan.zhihu.com/p/139363948
   - 时钟树功耗：时钟树的功耗通常占整个SOC功耗的40%左右，这是因为时钟是一直在翻转的信号，所以动态功耗特别大。所以 *门控时钟技术* 就特别重要。
   - CPU： CPU是SOC主控制器，工作时CPU一般都必须要打开，随着CPU频率越来越高，功耗也越来越大。所以现在的多核，大小核就比较流行，不同场景下用不同功耗的CPU核;
   - GPU: GPU是并行处理单元，由于其算力主要来自多个模块并行计算，为了正常工作，通常需要很多模块同时运算，功耗也很大，所以很多SOC都不带GPU或者 *默认关掉* ；
   - 存储器：DDR这些存储器作为SOC主存也需要时刻使用，也是功耗消耗的大户。

* Digital Circuit
** DONE 开关->逻辑运算
   CLOSED: [2020-08-04 Tue 09:38]

 有两种思路来实现开关到逻辑运算：

 一种是数电的思路：
 互补开关两端接高电平和低电平，
 用输入信号作为开关控制信号控制开关的截至和导通两个状态，开关输出的高低电平作为逻辑门的输出。

 一种是FPGA的思路：
 开关是MOS（三极管），逻辑门是FPGA的LUT构成的，LUT是16x1 SRAM，4个输入，一个输出。
 那么问题转化为：mos怎么组成SRAM。

*** DONE 开关工作原理
    CLOSED: [2020-08-03 Mon 08:51]

 门电路中的二极管和三极管经常工作在开关状态，所以开关的工作原理和门电路的开关状态密切相关。

**** 二极管

 二极管的正向导通的特性可以当作开关来用：二极管一端接VCC，一端接控制电压。

 二级管不能当作理想的开关，根据其伏安特性可知，负电压时有微弱电流，正电压较小时电阻较大保持不变，正电压较大时电阻快速减小。

**** CMOS

 功耗低，适用于大规模集成电路

 P型半导体衬底上布置两个N区（源极和漏极），栅极和衬底之间被二氧化硅绝缘层隔开。
 1. 在源极和漏极加电压，而栅极和源极之间无电压：
    由于源极和漏极之间相当于两个PN结背向串联，所以不导通，电流为0。
 2. 在源极和漏极加电压，而栅极和源极之间加正电压VGS：
    当VGS大于阈值电压时，由于栅极和衬底之间电场的吸引，使衬底中少数载流子聚集到栅极下面的衬底表面，形成一个N型反型区，构成了源极和漏极之间的导电沟道，有电流。
    随着VGS的升高，导电沟道面积增大，电流增大

 为了防止电流从衬底流向源极和导电沟道，通常将衬底和源极相连，或将衬底接到系统最低电位。

**** TTL

 TTL最早使用，面积小。但功耗大，只用用作小规模集成电路

*** DONE 开关到逻辑门
    CLOSED: [2020-08-03 Mon 18:47] SCHEDULED: <2020-08-03 Mon 14:40>

 通过开关控制门电路的通断，使得输出信号处于特定的高电平或低电平。

**** 二极管

 二极管电路存在严重的电压偏移问题。

***** 二极管与门

 两个二极管并联，接到电阻的下拉端。输出在电阻的上拉端。

***** 二极管或门

 两个二极管并联，接到电阻的上拉端。输出在电阻的下拉端

**** MOS

 特性曲线：纵轴是i_D，横轴是v_DS，不同的曲线是不同的v_GS。

 截止区：当v_GS < v_GS(thshold)时，源极和漏极之间没有导电沟道，D-S间的内阻特别大，i_D近似为零；
 可变电阻区：当v_GS > v_GS(thshold)时，源极和漏极之间有电流。当v_DS较小时，i_D与v_DS的比值近似于一个常数，其阻值随v_DS增大而变小；
 横流区：当v_GS > v_GS(thshold)时，当v_DS较大时，电流饱和，电流随v_DS增大而增大。

***** 反向器

 N沟道增强型和P沟道增强型串联（漏极相连），v_i是两个栅极之间的电压，v_o是连结的漏极之间的电压。
 翻转的阈值电压是v_DD / 2

***** 逻辑电路

 参考：[[https://mp.weixin.qq.com/s?__biz=Mzg3OTAyNTQ4MA==&mid=2247483706&idx=3&sn=1516766b846161a1c6b00b645bc40bb7&chksm=cf0b8d1df87c040bc783242543d9b140513f7577e7d1e29c416054f6f5272731d0fb26884c91&scene=21#wechat_redirect][三个常见的CMOS门电路]]
 有与非门和反向器，可以组成任意逻辑电路

**** TTL

 管芯由三层P型和N型半导体结合在一起，有NPN和PNP两种。三个电极是集电极c、基极b、发射极e。
 符号中的箭头指向N型半导体。

 特性曲线：纵轴是i_C，横轴是v_CE，不同的曲线是不同的i_B。i_B为开关控制信号。
 电流放大倍数：i_C和i_B的比值

***** 反向器

 接地的开关，接Vcc端是输出，输入是开关的控制端。

*** DONE SRAM
    CLOSED: [2020-07-20 周一 08:40]

 SRAM的储存单元是SR锁存器，由6根N沟道增强MOS管，可以保存0或1的信息。在上电的整个过程中都有效，不用刷新。

 利用晶体管来存储数据。与DRAM相比，SRAM的速度快，但在同样面积中SRAM的容量要比其它类型的内存小。

 行地址选择器：地址的低n位，作为字线(word line)，进行地址译码2^n之后，选择某一行。共有2^n * 2^n个存储单元。
 列地址选择器：地址的高m位，将2^n个存储单元分为2^m组，每组的数量2^n/2^m = 2^(n-m)就是输出位数。

*** DONE LUT
    CLOSED: [2020-07-30 周四 17:07]

 真值表可以唯一地表示逻辑运算，LUT就是一块存储空间，存储了真值表的所有结果，逻辑运算的输入信号作为存储地址，选择对应存储内容输出。

 通过LUP实现逻辑运算，其原理就是编码/解码：将逻辑输入的所有可能编码（真值表），存放在SRAM中，对于任一逻辑输入，在SRAM中查找对应的解码值。其优秀之处，在于，输入直接作为地址信号，直接得到解码输出，效率很高。

*** DONE 逻辑块
    CLOSED: [2020-08-04 Tue 09:38]

 将逻辑运算划分到不同的LUT中，在逻辑块中分配LUT。主要的工作在于如何实现LUT的高利用率。

 解释一下LUT的利用率问题：
 因为常见的6-LUT，有6个输入端，也就意味着能够表示6个逻辑变量的逻辑函数。如果逻辑变量少于6个，没有用到的端口是不能利用的，就会造成浪费。
 为什么没有用到的端口不能利用：因为每个查找表一次只能产生一个输出，如果两个或多个逻辑函数就需要多个输出。
 错误！！ 可以通过将6-LUT分为多个5或4-LUT的方式，有多个输出。但是只能由2个5-LUT或者4个4-LUT或者3-LUT的分法，并且分开之后的查找表是有公共引脚的，不能配置为任意逻辑函数。
 可参见stratix-V-board.pdf

 常见的方法是，将一个大查找表分为多个小查找表，具有相同的输入，将输入变量相同但功能不同的函数，放在同一个查找表中。
