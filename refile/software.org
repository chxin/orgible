* Source Code
  :PROPERTIES:
  :ID:       35E29ECD-95A1-4CDE-93CF-5E362449B743
  :END:
** CANCELLED googletest source code reading                       :CANCELLED:
   [2020-02-14 Fri 10:07]

   repo: https://github.com/google/googletest.git
  
*** the process about handling main parameter need a second reading
*** other part cannot understand
* Coding Philosophy
** code compared with c++ primer
*** find word in a file and print the line
    :LOGBOOK:
    CLOCK: [2020-03-22 Sun 17:24]--[2020-03-22 Sun 18:05] =>  0:41
    :END:
    [[~/Documents/Snippet/CPP/primer-12-3.cpp][cpp file]]

*** reproduce code according to c++ primer

    [[~/Documents/Snippet/CPP/primer-12-3-official.cpp][c++ primer code file]]

** DONE C++ Project Framework                                          :NOTE:
   CLOSED: [2020-03-31 Tue 21:41] DEADLINE: <2020-03-30 Mon 22:00>
   :PROPERTIES:
   :ID:       1D8F715F-A30B-432C-AA70-63D1FE8545E7
   :END:
   :LOGBOOK:
   CLOCK: [2020-03-05 Thu 18:12]--[2020-03-05 Thu 18:14] =>  0:02
   :END:
   [2020-03-05 Thu 18:12]

*** construct a c++ project?
    [[/Users/xin/Documents/Garage/template/cpp/cmake-examples/README.adoc][cmake usage]]
**** hierarchy
     [[/Users/xin/Documents/Garage/template/cpp/cpp-demo/][demo project]]

     /Users/xin/Documents/Garage/template/cpp/cpp-demo
     ├── CMakeLists.txt
     ├── README.org
     ├── bin
     │   ├── debug
     │   ├── lib
     │   │   ├── demo.o
     │   │   └── demo.so
     │   └── release
     ├── build
     ├── doc
     │   └── issue
     ├── example
     │   └── demo
     │       └── main.cpp
     ├── include
     │   ├── demo.hpp
     │   └── google-test
     │       ├── CMakeLists.txt
     │       └── CMakeLists.txt.in
     ├── license
     ├── makefile
     ├── post_test.sh
     ├── pre_test.sh
     ├── run_test.sh
     ├── src
     │   └── demo.cpp
     └── test
         └── unit-tests.cpp

**** cmake command
     1. CMakeLists.txt is the file which should store all your CMake commands.
     2. cmake_minimum_required(VERSION 3.5)
     3. project (hello_cmake)
        set the project name to make referencing certain variables easier when using multiple projects.
        the project() function, will create a variable ${PROJECT_NAME} with the value hello_cmake.
     4. add_executable(hello_cmake main.cpp)
        The add_executable() command specifies that an executable should be build from the specified source files.
        The first argument to the add_executable() function is the name of the executable to be built, and the second argument is the list of source files to compile.
     5. ${CMAKE_BINARY_DIR}
        The root or top level folder that you run the cmake command from is known as your CMAKE_BINARY_DIR and is the root folder for all your binary files.
     6. Out-of-Source Build vs In-Place Build
     7. Directory paths
        |--------------------------+-------------------------------------------------------------------------------------------|
        | Variable                 | Info                                                                                      |
        |--------------------------+-------------------------------------------------------------------------------------------|
        | CMAKE_SOURCE_DIR         | The root source directory                                                                 |
        | CMAKE_CURRENT_SOURCE_DIR | The current source directory if using sub-projects and directories.                       |
        | PROJECT_SOURCE_DIR       | The source directory of the current cmake project.                                        |
        | CMAKE_BINARY_DIR         | The root binary / build directory. This is the directory where you ran the cmake command. |
        | CMAKE_CURRENT_BINARY_DIR | The build directory you are currently in.                                                 |
        | PROJECT_BINARY_DIR       | The build directory for the current project.                                              |
        |--------------------------+-------------------------------------------------------------------------------------------|
     8. Source Files Variable
        Creating a variable which includes the source files and add them to multiple commands

        set(SOURCES src/Hello.cpp src/main.cpp)
        add_executable(${PROJECT_NAME} ${SOURCES})
     9. setting specific file names in the SOURCES variable use a =GLOB= command to find files using *wildcard pattern matching*.

         file(GLOB SOURCES "src/*.cpp")

          or use add_xxx function.
     10. include folders
        different include folders, you can make your compiler aware of them using the target_include_directories() When compiling this target this will add these directories to the compiler with the -I flag e.g. `-I/directory/path`

        target_include_directories(target PRIVATE ${PROJECT_SOURCE_DIR}/include)

        The directory passed to target_include_directories will be the root of your include directory tree and your C++ files should include the path from there to your header.
         #include "static/Hello.h" not #include "../include/static/Hello.h"

        This will cause the included directory used in the following places:
         - When compiling the library
         - When compiling any additional target that links the library.

         PRIVATE : the directory is added to this target's include directories
         INTERFACE : the directory is added to the include directores for any targets that link this library.
         PUBLIC : As above, it is included int his library and also any targets that link this library.

         For public headers it is often a good idea to have your include folder be "namespaced" with sub-directories.
         Using this method means that there is less chance of header filename clashes when
         you use multiple libraries in your project.

     11. make VERBOSE=1
        show full message
     12. Adding a Static Library
        The add_library() function is used to *create* a static library named ***.a from some source files.

        add_library(hello_library STATIC src/Hello.cpp)
     13. Adding a Shared Library
         add_library(hello_library SHARED src/Hello.cpp)
     14. Alias Target
         add_library(hello::library ALIAS hello_library)
     15. Linking a Library
        creating an executable that will use your library. just like "-rdynamic libhello_library.a"

        add_executable(hello_binary src/main.cpp)

        target_link_libraries( hello_binary PRIVATE hello_library)
     16. Installing
        CMake offers the ability to add a `make install` target to allow a user to install binaries, libraries and other files.
        `cmake .. -DCMAKE_INSTALL_PREFIX=/install/location`
        make install DESTDIR=/tmp/stage
        make uninstall

        configure install location
        if( CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT )
        message(STATUS "Setting default CMAKE_INSTALL_PREFIX path to ${CMAKE_BINARY_DIR}/install")
        set(CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}/install" CACHE STRING "The path to use for make install" FORCE)
        endif()

        install (TARGETS target_bin DESTINATION bin)

        install (TARGETS target_lib LIBRARY DESTINATION lib)

        for windows
        install (TARGETS target_lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin)

        install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/ DESTINATION include)

        install (FILES cmake-examples.conf DESTINATION etc)

     17. build type

         cmake .. -DCMAKE_BUILD_TYPE=Release

         - Release - Adds the `-O3 -DNDEBUG` flags to the compiler # -O3 最高级别的优化，-DNDEBUG屏蔽断言
         - Debug - Adds the `-g` flag # -g 添加调试信息
         - MinSizeRel - Adds `-Os -DNDEBUG` # -Os 2.5级优化，比2级多了代码压缩
         - RelWithDebInfo - Adds `-O2 -g -DNDEBUG` flags

           set default build type
           if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
              message("Setting build type to 'RelWithDebInfo' as none was specified.")
              set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Choose the type of build." FORCE)
              # Set the possible values of build type for cmake-gui
              set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
              "MinSizeRel" "RelWithDebInfo")
           endif()
     19. compile flag
         cmake .. -DCMAKE_CXX_FLAGS="-DEX3"

         add flag: -DEX3
         target_compile_definitions(cmake_examples_compile_flags PRIVATE EX3)

         set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DEX2" CACHE STRING "Set C++ Compiler Flags" FORCE)
         The values `CACHE STRING "Set C++ Compiler Flags" FORCE` from the above command are used to force this variable to be set in the CMakeCache.txt file.
         Once set the CMAKE_C_FLAGS and CMAKE_CXX_FLAGS will set a compler flag / definiton globally for all targets in this directory or any included sub-directories. This method is not recommended for general usage now and the target_compile_definitions function is preferred.
     20. third party lib
         #include<boost/filesystem.hpp>
         find_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system)
         This will search for CMake modules in the format "FindXXX.cmake" from the list of folders in `CMAKE_MODULE_PATH`.
         On linux the default search path will include `/usr/share/cmake/Modules`.

         The arguments are:
         - Boost - Name of the library. This is part of used to find the module file FindBoost.cmake
         - 1.46.1 - The minimum version of boost to find
         - REQUIRED - Tells the module that this is required and to fail it it cannot be found
         - COMPONENTS - The list of libraries to find.

         check if found
         if(Boost_FOUND)
             message ("boost found")
             include_directories(${Boost_INCLUDE_DIRS})
             else()
             message (FATAL_ERROR "Cannot find Boost")
         endif()

         `Boost_INCLUDE_DIRS` - The path to the include directory for the library
         xxx_LIBRARY - A variable pointing to the library path.

         # Include the boost headers
         target_include_directories( third_party_include
             PRIVATE ${Boost_INCLUDE_DIRS}
         )

         # link against the boost libraries
         target_link_libraries( third_party_include
             PRIVATE
             ${Boost_SYSTEM_LIBRARY}
             ${Boost_FILESYSTEM_LIBRARY}
         )

         use alias
         the library target is exported by find command and exported result alias as LibName::subsystem
           - `Boost::boost` for header only libraries
           - `Boost::system` for the boost system library.
           - `Boost::filesystem` for filesystem library.

         ref alias
         target_link_libraries( imported_targets PRIVATE Boost::filesystem)

     21. compiler configure
         cmake .. -DCMAKE_C_COMPILER=clang-3.6 -DCMAKE_CXX_COMPILER=clang++-3.6

         - CMAKE_C_COMPILER - The program used to compile c code.
         - CMAKE_CXX_COMPILER - The program used to compile c++ code.
         - CMAKE_LINKER - The program used to link your binary.
     22. c++ standard
         set(CMAKE_CXX_STANDARD 11)
     23. subproject
         add_subdirectory(sublibrary1)
         add_library(sub::lib2 ALIAS sublibrary2)

         The variables created by CMake add_subdirectory command:
         |--------------------+-------------------------------------------------------------------------------------------|
         | Variable           | Info                                                                                      |
         |--------------------+-------------------------------------------------------------------------------------------|
         | PROJECT_NAME       | The name of the project set by the current `project()`.                                   |
         | CMAKE_PROJECT_NAME | the name of the first project set by the `project()` command, i.e. the top level project. |
         | PROJECT_SOURCE_DIR | The source director of the current project.                                               |
         | PROJECT_BINARY_DIR | The build directory for the current project.                                              |
         | name_SOURCE_DIR    | The source directory of the project called "name".                                        |
         | name_BINARY_DIR    | The binary directory of the project called "name".                                        |
         |--------------------+-------------------------------------------------------------------------------------------|

         subdirectory only head file
         add_library(${PROJECT_NAME} INTERFACE)

*** header file should and should not
**** should not
     原则：尽量把能放到源文件cpp的代码都放到源文件里,头文件中应该只能有public APIs.其他所有的属于implementation detail的东西都应当放在源文件里面。一个项目的递交经常是public APIs + compiled library （for linking）。
***** using namespace std;

      cause unexpected name conflict

      类的定义
***** includes
      如果放在头文件，即使include的那个文件没有变动，也会被重新编译。
      比如class A里有class B的成员，计算A的内存布局需要用到B的内存布局信息，所以就需要在定义class A前include B。
      而如果只是有一个B*， 即指向B的指针（引用同理），由于指针大小是确定的，所以不需要B的内存布局，也不需要include B。
      这时候只要向前声明一个 class B就可以了。而如果代码里使用了B的方法，那编译器也需要能在此之前看到该方法的定义，所以也需要include。

**** should
     原则：接口文件放在头文件中
***** 声明
      extern变量的声明、函数的声明
***** 定义
      类的定义、枚举的定义、const int的定义、inline函数的定义

      头文件中可以写const对象的定义。因为全局的const对象默认是没有extern的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个.cpp文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些.cpp文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些.cpp文件中的这个const对象的值是相同的，可谓一举两得。同理，static对象的定义也可以放进头文件。
***** 依赖
      头文件的依赖一定要写清楚

     #inlcude<iostream> 应该放在头文件，还是源文件？
     接口定义中没有使用到，就不放在头文件
*** 静态库和动态库
**** 导出不同
**** 链接不同
     静态库对函数库的链接是放在编译时期完成的。
     动态库在程序运行是才被载入

     一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件
     空间浪费是静态库的一个问题。
*** mix c and c++
 What do I need to know when mixing C and C++ code?

 Here are some high points (though some compiler-vendors might not require all these; check with your compiler-vendor’s documentation):

 You must use your C++ compiler when compiling main() (e.g., for static initialization)
 Your C++ compiler should direct the linking process (e.g., so it can get its special libraries)
 Your C and C++ compilers probably need to come from the same vendor and have compatible versions (e.g., so they have the same calling conventions)
 In addition, you’ll need to read the rest of this section to find out how to make your C functions callable by C++ and/or your C++ functions callable by C.

 BTW there is another way to handle this whole thing: compile all your code (even your C-style code) using a C++ compiler. That pretty much eliminates the need to mix C and C++, plus it will cause you to be more careful (and possibly —hopefully!— discover some bugs) in your C-style code. The down-side is that you’ll need to update your C-style code in certain ways, basically because the C++ compiler is more careful/picky than your C compiler. The point is that the effort required to clean up your C-style code may be less than the effort required to mix C and C++, and as a bonus you get cleaned up C-style code. Obviously you don’t have much of a choice if you’re not able to alter your C-style code (e.g., if it’s from a third-party).

 How do I call a C function from C++?

 Just declare the C function extern "C" (in your C++ code) and call it (from your C or C++ code). For example:

     // C++ code

     extern "C" void f(int); // one way

     extern "C" {    // another way
         int g(double);
         double h();
     };

     void code(int i, double d)
     {
         f(i);
         int ii = g(d);
         double dd = h();
         // ...
     }
 The definitions of the functions may look like this:

     /* C code: */

     void f(int i)
     {
         /* ... */
     }

     int g(double d)
     {
         /* ... */
     }

     double h()
     {
         /* ... */
     }
 Note that C++ type rules, not C rules, are used. So you can’t call function declared extern "C" with the wrong number of arguments. For example:

     // C++ code

     void more_code(int i, double d)
     {
         double dd = h(i,d); // error: unexpected arguments
         // ...
     }
 How do I call a C++ function from C?

 Just declare the C++ function extern "C" (in your C++ code) and call it (from your C or C++ code). For example:

     // C++ code:

     extern "C" void f(int);

     void f(int i)
     {
         // ...
     }
 Now f() can be used like this:

     /* C code: */

     void f(int);

     void cc(int i)
     {
         f(i);
         /* ... */
     }
 Naturally, this works only for non-member functions. If you want to call member functions (incl. virtual functions) from C, you need to provide a simple wrapper. For example:

     // C++ code:

     class C {
         // ...
         virtual double f(int);
     };

     extern "C" double call_C_f(C* p, int i) // wrapper function
     {
         return p->f(i);
     }
 Now C::f() can be used like this:

     /* C code: */

     double call_C_f(struct C* p, int i);

     void ccc(struct C* p, int i)
     {
         double d = call_C_f(p,i);
         /* ... */
     }
 If you want to call overloaded functions from C, you must provide wrappers with distinct names for the C code to use. For example:

     // C++ code:

     void f(int);
     void f(double);

     extern "C" void f_i(int i) { f(i); }
     extern "C" void f_d(double d) { f(d); }
 Now the f() functions can be used like this:

     /* C code: */

     void f_i(int);
     void f_d(double);

     void cccc(int i,double d)
     {
         f_i(i);
         f_d(d);
         /* ... */
     }
 Note that these techniques can be used to call a C++ library from C code even if you cannot (or do not want to) modify the C++ headers.

 How can I include a standard C header file in my C++ code?

 To #include a standard header file (such as <cstdio>), you don’t have to do anything unusual. E.g.,

 // This is C++ code

 #include <cstdio>                // Nothing unusual in #include line

 int main()
 {
   std::printf("Hello world\n");  // Nothing unusual in the call either
   // ...
 }
 If you think the std:: part of the std::printf() call is unusual, then the best thing to do is “get over it.” In other words, it’s the standard way to use names in the standard library, so you might as well start getting used to it now.

 However if you are compiling C code using your C++ compiler, you don’t want to have to tweak all these calls from printf() to std::printf(). Fortunately in this case the C code will use the old-style header <stdio.h> rather than the new-style header <cstdio>, and the magic of namespaces will take care of everything else:

 /* This is C code that I'm compiling using a C++ compiler */

 #include <stdio.h>          /* Nothing unusual in #include line */

 int main()
 {
   printf("Hello world\n");  /* Nothing unusual in the call either */
   // ...
 }
 Final comment: if you have C headers that are not part of the standard library, we have somewhat different guidelines for you. There are two cases: either you can’t change the header, or you can change the header.

 How can I include a non-system C header file in my C++ code?

 If you are including a C header file that isn’t provided by the system, you may need to wrap the #include line in an extern "C" { /*...*/ } construct. This tells the C++ compiler that the functions declared in the header file are C functions.

 // This is C++ code

 extern "C" {
   // Get declaration for f(int i, char c, float x)
   #include "my-C-code.h"
 }

 int main()
 {
   f(7, 'x', 3.14);   // Note: nothing unusual in the call
   // ...
 }
 Note: Somewhat different guidelines apply for C headers provided by the system (such as <cstdio>) and for C headers that you can change.

 How can I modify my own C header files so it’s easier to #include them in C++ code?

 If you are including a C header file that isn’t provided by the system, and if you are able to change the C header, you should strongly consider adding the extern "C" {...} logic inside the header to make it easier for C++ users to #include it into their C++ code. Since a C compiler won’t understand the extern "C" construct, you must wrap the extern "C" { and } lines in an #ifdef so they won’t be seen by normal C compilers.

 Step #1: Put the following lines at the very top of your C header file (note: the symbol __cplusplus is #defined if/only-if the compiler is a C++ compiler):

 #ifdef __cplusplus
 extern "C" {
 #endif
 Step #2: Put the following lines at the very bottom of your C header file:

 #ifdef __cplusplus
 }
 #endif
 Now you can #include your C header without any extern "C" nonsense in your C++ code:

 // This is C++ code

 // Get declaration for f(int i, char c, float x)
 #include "my-C-code.h"   // Note: nothing unusual in #include line

 int main()
 {
   f(7, 'x', 3.14);       // Note: nothing unusual in the call
   // ...
 }
 Note: Somewhat different guidelines apply for C headers provided by the system (such as <cstdio>) and for C headers that you can’t change.

 Note: #define macros are evil in 4 different ways: evil#1, evil#2, evil#3, and evil#4. But they’re still useful sometimes. Just wash your hands after using them.

 How can I call a non-system C function f(int,char,float) from my C++ code?

 If you have an individual C function that you want to call, and for some reason you don’t have or don’t want to #include a C header file in which that function is declared, you can declare the individual C function in your C++ code using the extern "C" syntax. Naturally you need to use the full function prototype:

 extern "C" void f(int i, char c, float x);
 A block of several C functions can be grouped via braces:

 extern "C" {
   void   f(int i, char c, float x);
   int    g(char* s, const char* s2);
   double sqrtOfSumOfSquares(double a, double b);
 }
 After this you simply call the function just as if it were a C++ function:

 int main()
 {
   f(7, 'x', 3.14);   // Note: nothing unusual in the call
   // ...
 }
 How can I create a C++ function f(int,char,float) that is callable by my C code?

 The C++ compiler must know that f(int,char,float) is to be called by a C compiler using the extern "C" construct:

 // This is C++ code

 // Declare f(int,char,float) using extern "C":
 extern "C" void f(int i, char c, float x);

 // ...

 // Define f(int,char,float) in some C++ module:
 void f(int i, char c, float x)
 {
   // ...
 }
 The extern "C" line tells the compiler that the external information sent to the linker should use C calling conventions and name mangling (e.g., preceded by a single underscore). Since name overloading isn’t supported by C, you can’t make several overloaded functions simultaneously callable by a C program.

 Why is the linker giving errors for C/C++ functions being called from C++/C functions?

 If you didn’t get your extern "C" right, you’ll sometimes get linker errors rather than compiler errors. This is due to the fact that C++ compilers usually “mangle” function names (e.g., to support function overloading) differently than C compilers.

 See the previous two FAQs on how to use extern "C".

 How can I pass an object of a C++ class to/from a C function?

 Here’s an example (for info on extern "C", see the previous two FAQs).

 Fred.h:

 /* This header can be read by both C and C++ compilers */
 #ifndef FRED_H
 #define FRED_H

 #ifdef __cplusplus
   class Fred {
   public:
     Fred();
     void wilma(int);
   private:
     int a_;
   };
 #else
   typedef
     struct Fred
       Fred;
 #endif

 #ifdef __cplusplus
 extern "C" {
 #endif

 #if defined(__STDC__) || defined(__cplusplus)
   extern void c_function(Fred*);   /* ANSI C prototypes */
   extern Fred* cplusplus_callback_function(Fred*);
 #else
   extern void c_function();        /* K&R style */
   extern Fred* cplusplus_callback_function();
 #endif

 #ifdef __cplusplus
 }
 #endif

 #endif /*FRED_H*/
 Fred.cpp:

 // This is C++ code

 #include "Fred.h"

 Fred::Fred() : a_(0) { }

 void Fred::wilma(int a) { }

 Fred* cplusplus_callback_function(Fred* fred)
 {
   fred->wilma(123);
   return fred;
 }
 main.cpp:

 // This is C++ code

 #include "Fred.h"

 int main()
 {
   Fred fred;
   c_function(&fred);
   // ...
 }
 c-function.c:

 /* This is C code */

 #include "Fred.h"

 void c_function(Fred* fred)
 {
   cplusplus_callback_function(fred);
 }
 Unlike your C++ code, your C code will not be able to tell that two pointers point at the same object unless the pointers are exactly the same type. For example, in C++ it is easy to check if a Derived* called dp points to the same object as is pointed to by a Base* called bp: just say if (dp == bp) .... The C++ compiler automatically converts both pointers to the same type, in this case to Base*, then compares them. Depending on the C++ compiler’s implementation details, this conversion sometimes changes the bits of a pointer’s value.

 (Technical aside: Most C++ compilers use a binary object layout that causes this conversion to happen with multiple inheritance and/or virtual inheritance. However the C++ language does not impose that object layout so in principle a conversion could also happen even with non-virtual single inheritance.)

 The point is simple: your C compiler will not know how to do that pointer conversion, so the conversion from Derived* to Base*, for example, must take place in code compiled with a C++ compiler, not in code compiled with a C compiler.

 NOTE: you must be especially careful when converting both to void* since that conversion will not allow either the C or C++ compiler to do the proper pointer adjustments! The comparison (x == y) might be false even if (b == d) is true:

 void f(Base* b, Derived* d)
 {
   if (b == d) {   ☺ Validly compares a Base* to a Derived*
     // ...
   }

   void* x = b;
   void* y = d;
   if (x == y) {   ☹ BAD FORM! DO NOT DO THIS!
     // ...
   }
 }
 As stated above, the above pointer conversions will typically happen with multiple and/or virtual inheritance, but please do not look at that as an exhaustive list of the only times when the pointer conversions will happen.

 You have been warned.

 If you really want to use void* pointers, here is the safe way to do it:

 void f(Base* b, Derived* d)
 {
   void* x = b;
   void* y = static_cast<Base*>(d);  // If conversion is needed, it will happen in the static_cast<>
   if (x == y) {   // ☺ Validly compares a Base* to a Derived*
     // ...
   }
 }
 Can my C function directly access data in an object of a C++ class?

 Sometimes.

 (For basic info on passing C++ objects to/from C functions, read the previous FAQ).

 You can safely access a C++ object’s data from a C function if the C++ class:

 Has no virtual functions (including inherited virtual functions)
 Has all its data in the same access-level section (private/protected/public)
 Has no fully-contained subobjects with virtual functions
 If the C++ class has any base classes at all (or if any fully contained subobjects have base classes), accessing the data will technically be non-portable, since class layout under inheritance isn’t imposed by the language. However in practice, all C++ compilers do it the same way: the base class object appears first (in left-to-right order in the event of multiple inheritance), and member objects follow.

 Furthermore, if the class (or any base class) contains any virtual functions, almost all C++ compilers put a void* into the object either at the location of the first virtual function or at the very beginning of the object. Again, this is not required by the language, but it is the way “everyone” does it.

 If the class has any virtual base classes, it is even more complicated and less portable. One common implementation technique is for objects to contain an object of the virtual base class (V) last (regardless of where V shows up as a virtual base class in the inheritance hierarchy). The rest of the object’s parts appear in the normal order. Every derived class that has V as a virtual base class actually has a pointer to the V part of the final object.

 Why do I feel like I’m “further from the machine” in C++ as opposed to C?

 Because you are.

 As an OO programming language, C++ allows you to model the problem domain itself, which allows you to program in the language of the problem domain rather than in the language of the solution domain.

 One of C’s great strengths is the fact that it has “no hidden mechanism”: what you see is what you get. You can read a C program and “see” every clock cycle. This is not the case in C++; old line C programmers (such as many of us once were) are often ambivalent (can you say, “hostile”?) about this feature. However after they’ve made the transition to OO thinking, they often realize that although C++ hides some mechanism from the programmer, it also provides a level of abstraction and economy of expression which lowers maintenance costs without destroying run-time performance.

 Naturally you can write bad code in any language; C++ doesn’t guarantee any particular level of quality, reusability, abstraction, or any other measure of “goodness.”

 C++ doesn’t try to make it impossible for bad programmers to write bad programs; it enables reasonable developers to create superior software
* Algorithm
** DONE Duplicate Operations Algorithm
   CLOSED: [2020-03-29 Sun 21:30]
*** DONE recursive programming                                         :NOTE:
    CLOSED: [2020-03-29 Sun 21:47] SCHEDULED: <2020-03-29 Sun 20:00-21:00>
    :PROPERTIES:
    :ID:       4999E010-DE33-4CBC-AA65-1169D96F9FB4
    :END:
    - State "FINISHED"   from "CANCELLED"  [2020-03-29 Sun 21:47]
    :LOGBOOK:
    CLOCK: [2020-03-05 Thu 09:46]--[2020-03-05 Thu 09:49] =>  0:03
    :END:
    [2020-03-05 Thu 09:46]
    使用递归：每次固定操作可以减少问题的n（可能是一个多维n^m的问题）
    递归函数：如何表示n，递归操作，终止条件

    [[https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ][递归及其优化参考文章]]

**** 递归三要素
 1. 这个函数想要干什么:要完成什么样的一件事
 2. 寻找递归结束条件: 当参数为啥时，递归结束，之后直接把结果返回.请注意，根据参数值能够直接知道函数的结果是什么，才可以作为结束条件。

   关于递归结束条件是否够严谨问题:结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。例如：f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。
 3. 不断缩小参数的范围：通过找出函数的等价关系式，例如f(n) = n * f(n - 1)
**** example
***** 斐波那契数列
 #+begin_src C++
 // 求第n项的数值
 // 该数等于前两个数之和 f(n) = f(n-1) + f(n-2)
 int Fibonacci(int n) {
     if(n <= 2) {
         return 1;
     }
     return f(n - 1) + f(n - 2);
 }
 #+end_src
***** 跳台阶问题
 #+begin_src C++
   // solve n stages is the same with n - 1 stages
   // how many of n stages

   int stages_backward(int n) {
       if(n <= 3) {
           return n;
       }
       return stages(n - 1) + stages(n - 2);
   }

   void stages_forward(int n, int total, int & result) {
       if(n == total) {
           return;
       }

       if(n < total)
       stages_forward(n + 1, total, result + 1);
       if(n < total - 1)
       stages_forward(n + 2, total, result + 1);
   }
 #+end_src
***** 链表反向
 #+begin_src C++
   struct node {
       int value;
       node * next;
   };

   // change node direction
   void reverse_link(node * node_tmp, node * next_node) {
       if(next_node == NULL) {
           return;
       }
       node * tmp = next_node->next;
       next_node->next = node_tmp;
       reverse_link(next_node, tmp);
   }

   int main(void) {
       // construct list;
       node * head;
       node * tmp = head->next;
       head->next = NULL;
       reverse_link(head, tmp);
   }
 #+end_src

**** 优化
***** 考虑是否重复计算
 如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。

 可以用数组或者 HashMap 保存，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让arr[n] 等于一个特殊值，例如 arr[n] = -1。 当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。
***** 考虑是否可以自底向上

 对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。
 不过，有时候当 n 比较大的时候，可能栈空间会不够用。

 /备注：/ 我常用的，例如：example2，从开始n = 0开始分析(所有可能的情况，只跳一个台阶，只跳两个台阶，都分别递归），这样递归深度不会少。这样的优化的方法又该如何进行呢？
 我使用递归的思路是：固定的操作，每次操作之后，问题的n减小了。在每次操作，也就是一个递归func中，对每个固定子操作执行并再次跳用递归

**** recursive vs Loop for cumulative(累加）
 递归中，重复操作太多了，可以通过数组记录结果的方法，减少重复。

 循环中，循环内部必然多次重复执行，也可以使用数组方法。

 但是，对于不知道循环次数的，只能递归才可以。
 对于遍历所有情况的，使用递归更方便。
*** DONE Dynamic programming
    CLOSED: [2020-03-28 Sat 20:43]
    利用历史记录，来避免我们的重复计算
**** 三个步骤
 - 定义数组元素的含义：dp[i] 代表什么意思？
 - 找出数组元素之间的关系式，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值：最优子结构
 - 找出初始值
**** 跳台阶问题
 #+begin_src C++ includes:iostream, vector
   int main(void) {
       int total(100);
       vector<int> dp(total, 0);
       dp[0] = 1;
       dp[1] = 2;
       for (int i = 2; i < total; ++i) {
           dp[i] = dp[i - 2] + dp[i - 1];
       }
       return dp[total - 1];
   }
 #+end_src

 - 定义 dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法
 - dp[n] 一定会和 dp[n-1], dp[n-2]....存在某种关系的。但是关系怎么找？
 - 蛙到达第 n 级的台阶有两种方式: 一种是从第 n-1 级跳上来, 一种是从第 n-2 级跳上来, 由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]。
 - 初始条件： n - 1 >= 0 , n - 2 >= 0， 得出n >= 2 时才可用公式，所以dp[0], dp[1]就是初值
 - 但是，dp[2]应该2， 不是dp[0] + dp[1]的和。。。。这就是对于dp[i]的定义的问题了，这里，i表示台阶阶数，从1开始比较合适
**** 跳棋问题
 #+begin_src C++
   int main(void) {
       int m(7);
       int n(3);

       int pos[m][n];
       pos[0][0] = 0;
       pos[0][1] = 1;
       pos[1][0] = 1;

       for (int i = 0; i < m; ++i) {
           for (int k = 0; k < n; ++k) {
               if(i - 1 >= 0 && k - 1 >= 0){
                   pos[i][k] = pos[i - 1][k] + pos[i][k - 1];
               } else if(i - 1 > 0) {
                   pos[i][k] = pos[i - 1][k];
               } else if(k - 1 > 0) {
                   pos[i][k] = pos[i][k - 1];
               }
           }
       }
       return pos[m - 1][n - 1];
   }
 #+end_src

 - 定义 dp[i] [j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径
 - 到达 (i, j) 这个位置有两种方式,一种是从 (i-1, j) 这个位置走一步到达,一种是从(i, j - 1) 这个位置走一步到达.因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]
** DONE Binary Search
   CLOSED: [2020-03-31 Tue 22:46] SCHEDULED: <2020-03-31 Tue 20:30-21:30>
   Knuth once said "Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky"
*** find a num in a array;
 #+begin_src C++
   int binary_search(int value, vector<int> & int_array) {
       vector::size_type start = 0;
       vector::size_type end = int_array.size() - 1;
       vector::size_type mid = (start + end) / 2;
       while(value != int_array.at(mid) && start != end) {
           if(value > int_array.at(mid)) {
               start = mid;
               end = end;
               mid = (start + end) / 2;
           } else {
               start = start;
               end = mid;
               mid = (start + end) / 2;
           }
       }
       if(start == end){
           return -1;
       }
       return mid;
   }
 #+end_src

 A better implementation
 #+begin_src C++
 int binarySearch(int[] nums, int target) {
     int left = 0;
     int right = nums.length - 1; // 注意, 确保[left, right]都有效。这种左右闭区间一定要牢记

     while(left <= right) { // 注意, 左右闭区间，如果left < right, 忽略了只有一个数值的情况， 如果left ！= right，和 < 一样的问题，同时忽略 > 的问题
         int mid = (right + left) / 2;
         if(nums[mid] == target)
             return mid;
         else if (nums[mid] < target)
             left = mid + 1; // 注意, 已经确认mid不符合，应去除
         else if (nums[mid] > target)
             right = mid - 1; // 注意
         }
     return -1;
 }
 #+end_src
*** 缺陷
**** 查找值有重复
     例如， 1 2 2 2 3，查找2，得到索引值是2。
     但是，索引值1和3都是对的，分别对应于左边界和右边界。如何应对这种需求呢

     左边界二分查找
 #+begin_src C++
 int left_bound(int[] nums, int target) {
     if (nums.length == 0) return -1;
     int left = 0;
     int right = nums.length; // 注意: [left, right)左闭右开区间

     while (left < right) { // 注意: 如果left == right，区间为空
         int mid = (left + right) / 2;
         if (nums[mid] == target) {
             right = mid; // 去除mid，保留左边
         } else if (nums[mid] < target) {
             left = mid + 1;
         } else if (nums[mid] > target) {
             right = mid; // 注意: 右边界为开区间
         }
     }

     if (left == nums.length) return -1; // target 比所有数都大
     return nums[left] == target ? left : -1; // 注意，返回left，不是mid；应该返回mid，但mid是while局部变量，已销毁，同时left = mid，可用于返回
 }
 #+end_src

     右边界二分查找
 #+begin_src C++
 int right_bound(int[] nums, int target) {
     if (nums.length == 0) return -1;
     int left = 0, right = nums.length; //[left, right)左闭右开区间

     while (left < right) {
         int mid = (left + right) / 2;
         if (nums[mid] == target) {
             left = mid + 1; // 注意，去除mid，保留右边
         } else if (nums[mid] < target) {
             left = mid + 1;
         } else if (nums[mid] > target) {
             right = mid;
         }
     }
     return left - 1; // 注意，应返回mid，因为while结束是num[left]不一定等于target，但num[mid]一定等于target（如果存在的话）. mid = left - 1
 }
 #+end_src

** DONE sort algorithm
   CLOSED: [2020-07-01 Wed 12:24] SCHEDULED: <2020-04-15 Wed 20:00-21:30>

 [[eww:https://mp.weixin.qq.com/s/ZU9SwtuC-iIWq69rXQLmKQ][C language 8 sort algorithm]]
 内部排序：整个排序过程不需要访问外存便能完成
 外部排序：参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成

*** 插入排序

 遍历数组中的元素，依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则逐步前移，直到大于前面的元素

*** 希尔排序

 二分gap，从gap位置向后遍历，对以gap等间距的稀疏数组，插入排序

*** 简单排序

 遍历下标，将下标之后的最小数字，放到该位置

*** 堆排序

 堆：任意的叶子结点大于父节点。
 将数组元素入堆，逐次取出跟节点并重排

*** 冒泡排序

 遍历所有元素，遍历该元素之后所有元素，相邻元素比较，如果大元素在前，就交换

*** 快速排序

 二分选择基准，将所有小于该基准的元素放到前面，所有大于该基准的元素放到后面

*** 归并排序

 分治法，先二分直到单个元素，在兄弟结点排序，合并到父节点

*** 基数排序

 用数组或map记录所有元素的个数，在从大到小，依次输出

** DONE Dynamic Programming
   CLOSED: [2020-07-01 Wed 12:24] DEADLINE: <2020-04-16 Thu 18:00>

 https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews?aff=K7qB

** 遍历二叉树

 #include <iostream>
 #include<string.h>
 #include<stack>
 usingnamespace std;

 typedef struct node
 {
     char data;
     struct node *lchild,*rchild;
 }BinTree;

 typedef struct node1
 {
     BinTree *btnode;
     bool isFirst;
 }BTNode;


 void creatBinTree(char*s,BinTree *&root)  //创建二叉树，s为形如A(B,C(D,E))形式的字符串
 {
     int i;
     bool isRight=false;
     stack<BinTree*> s1;          //存放结点
     stack<char> s2;              //存放分隔符
     BinTree *p,*temp;
     root->data=s[0];
     root->lchild=NULL;
     root->rchild=NULL;
     s1.push(root);
     i=1;
     while(i<strlen(s))
     {
         if(s[i]=='(')
         {
             s2.push(s[i]);
             isRight=false;
         }
         elseif(s[i]==',')
         {
             isRight=true;
         }
         elseif(s[i]==')')
         {
             s1.pop();
             s2.pop();
         }
         elseif(isalpha(s[i]))
         {
             p=(BinTree *)malloc(sizeof(BinTree));
             p->data=s[i];
             p->lchild=NULL;
             p->rchild=NULL;
             temp=s1.top();
             if(isRight==true)
             {
                 temp->rchild=p;
                 cout<<temp->data<<"的右孩子是"<<s[i]<<endl;
             }
             else
             {
                 temp->lchild=p;
                 cout<<temp->data<<"的左孩子是"<<s[i]<<endl;
             }
             if(s[i+1]=='(')
                 s1.push(p);
         }
         i++;
     }
 }

 void display(BinTree *root)        //显示树形结构
 {
     if(root!=NULL)
     {
         cout<<root->data;
         if(root->lchild!=NULL)
         {
             cout<<'(';
             display(root->lchild);
         }
         if(root->rchild!=NULL)
         {
             cout<<',';
             display(root->rchild);
             cout<<')';
         }
     }
 }

 void preOrder1(BinTree *root)     //递归前序遍历
 {
     if(root!=NULL)
     {
         cout<<root->data<<"";
         preOrder1(root->lchild);
         preOrder1(root->rchild);
     }
 }

 void inOrder1(BinTree *root)      //递归中序遍历
 {
     if(root!=NULL)
     {
         inOrder1(root->lchild);
         cout<<root->data<<"";
         inOrder1(root->rchild);
     }
 }

 void postOrder1(BinTree *root)    //递归后序遍历
 {
     if(root!=NULL)
     {
         postOrder1(root->lchild);
         postOrder1(root->rchild);
         cout<<root->data<<"";
     }
 }

 void preOrder2(BinTree *root)     //非递归前序遍历
 {
     stack<BinTree*> s;
     BinTree *p=root;
     while(p!=NULL||!s.empty())
     {
         while(p!=NULL)
         {
             cout<<p->data<<"";
             s.push(p);
             p=p->lchild;
         }
         if(!s.empty())
         {
             p=s.top();
             s.pop();
             p=p->rchild;
         }
     }
 }

 void inOrder2(BinTree *root)      //非递归中序遍历
 {
     stack<BinTree*> s;
     BinTree *p=root;
     while(p!=NULL||!s.empty())
     {
         while(p!=NULL)
         {
             s.push(p);
             p=p->lchild;
         }
         if(!s.empty())
         {
             p=s.top();
             cout<<p->data<<"";
             s.pop();
             p=p->rchild;
         }
     }
 }

 void postOrder2(BinTree *root)    //非递归后序遍历
 {
     stack<BTNode*> s;
     BinTree *p=root;
     BTNode *temp;
     while(p!=NULL||!s.empty())
     {
         while(p!=NULL)              //沿左子树一直往下搜索，直至出现没有左子树的结点
          {
             BTNode *btn=(BTNode *)malloc(sizeof(BTNode));
             btn->btnode=p;
             btn->isFirst=true;
             s.push(btn);
             p=p->lchild;
         }
         if(!s.empty())
         {
             temp=s.top();
             s.pop();
             if(temp->isFirst==true)     //表示是第一次出现在栈顶
              {
                 temp->isFirst=false;
                 s.push(temp);
                 p=temp->btnode->rchild;
             }
             else//第二次出现在栈顶
              {
                 cout<<temp->btnode->data<<"";
                 p=NULL;
             }
         }
     }
 }

 void postOrder3(BinTree *root)     //非递归后序遍历
 {
     stack<BinTree*> s;
     BinTree *cur;                      //当前结点
     BinTree *pre=NULL;                 //前一次访问的结点
     s.push(root);
     while(!s.empty())
     {
         cur=s.top();
         if((cur->lchild==NULL&&cur->rchild==NULL)||
            (pre!=NULL&&(pre==cur->lchild||pre==cur->rchild)))
         {
             cout<<cur->data<<"";  //如果当前结点没有孩子结点或者孩子节点都已被访问过
               s.pop();
             pre=cur;
         }
         else
         {
             if(cur->rchild!=NULL)
                 s.push(cur->rchild);
             if(cur->lchild!=NULL)
                 s.push(cur->lchild);
         }
     }
 }


 int main(int argc, char*argv[])
 {
     char s[100];
     while(scanf("%s",s)==1)
     {
         BinTree *root=(BinTree *)malloc(sizeof(BinTree));
         creatBinTree(s,root);
         display(root);
         cout<<endl;
         preOrder2(root);
         cout<<endl;
         inOrder2(root);
         cout<<endl;
         postOrder2(root);
         cout<<endl;
         postOrder3(root);
         cout<<endl;
     }
     return0;
 }

** TODO 位运算
 https://blog.csdn.net/deaidai/article/details/78167367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf
* Networking
** DONE C++ Network Lib: asio
   CLOSED: [2020-04-15 Wed 16:04]
   :LOGBOOK:
   CLOCK: [2020-04-10 Fri 15:51]--[2020-07-02 Thu 17:38] => 1993:47
   :END:

 resource: 
 - [[http://think-async.com/Asio/asio-1.16.0/doc/][HTML documentation (non-Boost)]]

 Asio is a *cross-platform* C++ library for network and *low-level I/O programming* that provides developers with a *consistent asynchronous* model using a modern C++ approach

 Asio has two versions: standalone asio without boost; with boost

*** demo: http server
 [[http://think-async.com/Asio/asio-1.16.0/doc/asio/tutorial.html][C++ ASIO tutorial]]

 #+begin_src C++
 #include <ctime>
 #include <iostream>
 #include <string>
 #include <boost/array.hpp>
 #include <boost/bind.hpp>
 #include <boost/shared_ptr.hpp>
 #include <boost/enable_shared_from_this.hpp>
 #include <asio.hpp>

 using asio::ip::tcp;
 using asio::ip::udp;

 std::string make_daytime_string()
 {
   using namespace std; // For time_t, time and ctime;
   time_t now = time(0);
   return ctime(&now);
 }

 class tcp_connection
   : public boost::enable_shared_from_this<tcp_connection>
 {
 public:
   typedef boost::shared_ptr<tcp_connection> pointer;

   static pointer create(asio::io_context& io_context)
   {
     return pointer(new tcp_connection(io_context));
   }

   tcp::socket& socket()
   {
     return socket_;
   }

   void start()
   {
     message_ = make_daytime_string();

     asio::async_write(socket_, asio::buffer(message_),
         boost::bind(&tcp_connection::handle_write, shared_from_this()));
   }

 private:
   tcp_connection(asio::io_context& io_context)
     : socket_(io_context)
   {
   }

   void handle_write()
   {
   }

   tcp::socket socket_;
   std::string message_;
 };

 class tcp_server
 {
 public:
   tcp_server(asio::io_context& io_context)
     : io_context_(io_context),
       acceptor_(io_context, tcp::endpoint(tcp::v4(), 13))
   {
     start_accept();
   }

 private:
   void start_accept()
   {
     tcp_connection::pointer new_connection =
       tcp_connection::create(io_context_);

     acceptor_.async_accept(new_connection->socket(),
         boost::bind(&tcp_server::handle_accept, this, new_connection,
           asio::placeholders::error));
   }

   void handle_accept(tcp_connection::pointer new_connection,
       const asio::error_code& error)
   {
     if (!error)
     {
       new_connection->start();
     }

     start_accept();
   }

   asio::io_context& io_context_;
   tcp::acceptor acceptor_;
 };

 class udp_server
 {
 public:
   udp_server(asio::io_context& io_context)
     : socket_(io_context, udp::endpoint(udp::v4(), 13))
   {
     start_receive();
   }

 private:
   void start_receive()
   {
     socket_.async_receive_from(
         asio::buffer(recv_buffer_), remote_endpoint_,
         boost::bind(&udp_server::handle_receive, this,
           asio::placeholders::error));
   }

   void handle_receive(const asio::error_code& error)
   {
     if (!error)
     {
       boost::shared_ptr<std::string> message(
           new std::string(make_daytime_string()));

       socket_.async_send_to(asio::buffer(*message), remote_endpoint_,
           boost::bind(&udp_server::handle_send, this, message));

       start_receive();
     }
   }

   void handle_send(boost::shared_ptr<std::string> /*message*/)
   {
   }

   udp::socket socket_;
   udp::endpoint remote_endpoint_;
   boost::array<char, 1> recv_buffer_;
 };

 int main()
 {
   try
   {
     asio::io_context io_context;
     tcp_server server1(io_context);
     udp_server server2(io_context);
     io_context.run();
   }
   catch (std::exception& e)
   {
     std::cerr << e.what() << std::endl;
   }

   return 0;
 }
 #+end_src
*** timer
 [[file+emacs:~/Documents/Snippet/CPP/Network/asio/tutorial/timer/][timer tutorial code]]
*** socket
 [[file+emacs:~/Documents/Snippet/CPP/Network/asio/tutorial/socket/][socket tutorial code]]
*** basic actions
 regard the socket io as file
**** client
 1. create socket
 2. connect server
 3. send data to server
 4. receive data
 5. close socket
**** server
 1. create socket
 2. bind port
 3. listen port
 4. accept connection
 5. receive data
 6. send data
 7. close socket
** DONE c++ multi-thread
   CLOSED: [2020-07-01 Wed 12:25] DEADLINE: <2020-06-07 Sun>
*** basic functions
 #+begin_src C++
 /* thread */
 std::thread t1(func, 6);
 std::this_thread::sleep_for(chrono::milliseconds(3));
 chrono::steady_clock::time_point tp = chrono::steady_clock::now() + chrono::microseconds(3);
 std::this_thread::sleep_until(tp);

 /* Mutex */
 std::mutex mu;
 std::lock_guard<std::mutex> locker(mu);
 std::unique_lock<std::mutex> ulocker(mu);
 ulocker.try_lock();
 ulocker.try_lock_for(chrono::nanoseconds(500));
 ulocker.try_lock_until(tp);

 /* Conditional Variable */
 std::condition_variable cond;
 cond.wait_for(ulocker, chrono::microseconds(2));
 cond.wait_until(ulocker, tp);

 /* Future and Promise */
 std::promise<int> p;
 std::future<int> f = p.get_future();
 f.get();
 f.wait();
 f.wait_for(chrono::milliseconds(2));
 f.wait_until(tp);

 /* async() */
 std::future<int> fu = async(func, 6);

 /* Package Task */
 std::packaged_task<int(int)> t(func);
 std::future<int> fu2 = t.get_future;
 t(6);
 #+end_src
*** create thread
 1. a thread object std::thread should have either join() or detach() function only once.
 2. other object such as std::bind, std::call_once, std::async
 3. make sure join() once and only once
  if(joinable())
 #+begin_src C++
 std::thread t1(func1);

 try {
     do_something();
 } catch (...) {  // catch all potential error
     t1.join();
     throw;       // stop
 }

 if(t1.joinable())
     t1.join();
 #+end_src
 4. thread function
 #+begin_src C++
 void func1() {
     do_func1();
 }

 class Factor {
 public:
     void func();
     void operator() () {
         do_func2();
     }
 };


 }

 int main() {
     std::thread t1(func1); // copy of func1 in thread
     std::thread t1(std::ref(func1)); // func1() in thread
     std::thread t1(std::move(func1)); // func1() in thread but no usable in main

     std::thread t2((Factor()));

     Factor f1;
     std::thread t3(f1);

     std::thread t4(&Factor::func, a); // copy of Factor.func1
     std::thread t4(&Factor::func, &a); // Factor.func1

     std::thread t5([](){return 0;});

 }
 #+end_src
 5. pass argument to thread function
 #+begin_src C++
 void func1(string s) {
     do_func1();
 }

 void func2(string & s) {
     do_func2();
 }

 int main() {
     string s = "hello, world";
     std::thread t1(func1, s);
     std::thread t2(func2, std::ref(s)); // s reference is passed to thread
     std::thread t3(func2, std::move(s)); // s is moved to thread and is no longer used in main thread
 }
 #+end_src

 6. thread function return value
 #+begin_src C++
 int func1() {
     return 1;
 }

 int main() {
 int x;
 # std::future<int> fu = std::async(func1); // run thread at once
 std::future<int> fu = std::async(std::launch::async | std::launch::deferred, func1); // run thread when fu.get()
 x = fu.get();
 }
 #+end_src

 if func1() have some parameter, use promise to set the value when needed
 #+begin_src C++
 int func1(int n) {
     return n;
 }
 int func2(std::future<int> & f) {
     return f.get();
 }

 int main() {
     std::promise<int> p;
     std::future<int> f = p.get_future;
     std::future<int> fu = std::async(std::launch::async | std::launch::deferred, func1, 1); // give argument directly
     std::future<int> fu2 = std::async(std::launch::async | std::launch::deferred, func2, std:ref(f)); // future give argument

 // ...

     p.set_value(4); // if not promise, exception: std::future_errc::broken_promise
     int x = fu.get();
 }
 #+end_src

 if main thread calls func2 thread for 1000, use shared_future
 #+begin_src C++
 int func(std::shared_future<int> f);

 std::shared_future<int> sf = f.share();
 std::future<int> fu3 = std::async(std::launch::async | std::launch::deferred, func2, sf);
 // .... 1000 thread
 std::future<int> fu1000 = std::async(std::launch::async | std::launch::deferred, func2, sf);

 #+end_src
*** thread management
 1. move vs copy
 - thread can only be moved
 #+begin_src C++
 std::thread t2 = t1; // wrong
 std::thread t3 = std::move(t1);
 #+end_src
 2. thread id
 #+begin_src C++
 auto id = std::this_thread::get_id(); // current thread id
 auto id = t1::get_id(); // thread t1 id
 #+end_src
 3. max thread nums
 #+begin_src C++
 auto nums = std::thread::hardware_concurrency(); // max running threads on my hardware
 #+end_src
*** mutex
 1. std::cout, most common shared resource may be used in both main thread or child thread
 2. lock() unlock()
 std::mutex mu;
 before change value, mu.lock(); after changed, mu.unlock()

 control all the shared resource not the specified, which is very bad
 3. lock_guard()
 std::lock_guard<std::mutex> guard(mu);
 helps lock and unlock automatically

 whenever the code go out the scope of guard, the mutex will always be unlock, which is note safe enough for global resource

 4. bind mutex and resource
 in any function, guard m_mutex before use f
 #+begin_src C++
 class BindClass {
 private:
     std::mutex m_mutex;
     ofstream f;
 private:

 }
 #+end_src

 to make sure f is inside the guard, and f cannot be accessed without going through guard
 - never return f to outside world;
 #+begin_src C++
 ofstream & getfstream() {return f;}
 #+end_src
 - never pass f as an argument to user provided function
 #+begin_src C++
 void procee_f(void fun(ofstream &)) { fun(f); }
 #+end_src
 5. guard range
 a stack has pop() and top() which both works on data inside.
 if pop() guard data and top() guard data separately, two thread may top(), top(), and pop(), pop(). the top data is got twice but next data is jumped.

 DESIGN interface APPROPRIATELY
 6. unique_lock
 because lock_guard() lock mutex since it executes until the function return.
 the mutex cannot be used even if data do not need locked.
 #+begin_src C++
 std::unique_lock<mutex> locker(mu);
 // ...
 locker.unlock();
 // unlock_process();
 locker.lock();

 locker.unlock();
 #+end_src
*** dead lock
  1. more than one mutex enable safe guarantee for files or else.
  #+begin_src C++
  if(!file.is_open()) {
      std::unique_lock<mutex> locker(mu_file); // before change file, lock it
      file.open("log.txt");
  }  // not safe: when two thread go into if{} at same time, file open twice synchronous

  {
      std::unique_lock<mutex> locker(mu_file); // before change file, lock it
      if(!file.is_open()) {
          file.open("log.txt");
      }
  } // not good: file.open() only conduct once, but lock every time

  if(locked == 0) {
      if(!file.is_open() {
          if(locked == 0) {
              locked = 1;
              file.open();
              locked = 0;
          }
      }
  } // wrong, not mutex

  std::lock(mu);
  do_something();
  std::unlock(mu);
  #+end_src

  2. once_flag for once operator such class instruction or file.open()
  std::once_flag _flag;

  std::call_once(_flag, [&](){_f.open("log");});

  3. dead lock.
  #+begin_src C++
  std::mutex mu1;
  std::mutex mu2;

  void func1() {
      std::lock_guard<std::mutex> guard1(mu1);
      std::lock_guard<std::mutex> guard2(mu2);
  }
  void func2() {
      std::lock_guard<std::mutex> guard2(mu2);
      std::lock_guard<std::mutex> guard1(mu1);
  }
  #+end_src

  thread1 call func1 and lock mu1, waiting for mu2; thread 2 call func2 and lock mu2, waiting for mu1.
  the both waiting is a dead lock.

  Avoid deaklock:
  - prefer guard locking single mutex and process, then another
  - avoid guard locking a mutex and then calling a user function which may lock other mutexs
  - use std::lock() to lock more than one mutex. use std::lock_guard<std::mutex> guard(mu1, std:adopt_lock) to avoid dead lock
  - guard lock mutex in same order in different function

**** wait and notify
  if two thread access data at different speed, instead of thread::sleep_for(chrono::seconds(1)), set fast as wait and slow one as notify

  the same usage is also ensure a thread occurs after another.

  std::condition_variable cond;

  // func1
  cond.notify_one(); // notify one waiting thread if any
  cond.notify_all();

  //func2
  cond.wait(unique_locker, [](){ return !q.empty() } ); // awake by locker or notification or lamda function
** DONE computer network
   CLOSED: [2020-06-15 Mon 21:49]
 在对每一层进行分析的时候，要考虑数据向下传输时，该层对上一层数据的封装；数据向上传输时，该层利用下一层可以执行的任务；
*** conception
**** 电路交换与分组交换

 - 电路交换

 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的 *物理链路* ，并且在整个通信过程中 *始终占用* 该链路。
 由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

 - 分组交换

 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换 *不需要占用传输线路* 。

 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。

 最大传输单元MTU：数据链路层1500B，

**** 存储转发与直通转发

 这是二层交换机收到数据后的两种处理方式

**** 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

 处理时延：分析首部、从分组中提取数据、进行差错检验或查找适当的路由

 传输时延：向数据总线发送数据帧所需要的时间

 传播时延：在信道中传播所需要花费的时间

**** 五层协议

 - 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

 - 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

 - 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

 - 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

 - 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

**** 通信方式

 信息在传输线上的传送方向

 - 单工通信：单向传输

 - 半双工通信：双向交替传输

 - 全双工通信：双向同时传输

*** 物理层
**** 数字信号与模拟信号

 - 数--模：带通调制（调幅、调频、调相、正交振幅调制）

 - 数--数：基带调制（比特流编码、归零编码、不归零编码、曼彻斯特编码、差分曼彻斯特编码）

 基带信号往往含有较多的低频成分或直流，信道不能传输

**** 信道复用

 - 频分复用（波分复用）

 - 时分复用、统计时分复用

 - 码分复用
 码片互相正交C1 * C2 = 0
   1. 发送端根据码片进行扩频：1扩为码片，0扩为码片的反码
   2. 信道上各信号叠加 (C1 + C2)
   3. 接收端与码片相乘，分离信号 (C1+C2)*C1 = C1*C1 + C2*C1 = C1 + 0

*** 数据链路层
**** 帧
 - 帧封装：
 根据比特流的开始和结束标志，将比特流提取出来，去掉数据链路层的信息，发到网络层。
 接受网络层的数据，加上数据链路层的信息，根据[[target-mac][目的mac地址]]，送到端口转为比特流。

 - 帧区分：增加头部、尾部
 帧使用首部和尾部进行定界。如果帧的数据部分含有和首部尾部相同的内容（8bit），那么帧的开始和结束位置就会被错误的判定。
 需要在数据部分出现首部尾部相同的内容前面插入转义字符（ESC）。在接收端进行处理之后可以还原出原始数据。
 - 差错控制：比特差错
 在数据段的最后加入循环冗余校验（CRC）

**** 信道
 - 广播信道（总线型）：检测碰撞，用[[CSMA/CD][CSMA/CD协议]]，避免碰撞，用信道复用
 - 点对点信道：不会碰撞，用PPP协议

**** CSMA/CD
 <<CSMA/CD>>
 载波监听多点接入 / 碰撞检测
 - 多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上。
 - 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
 - 碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

 争用期：端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

 最短帧长度64B：传输延时要大于争用期

 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间

**** 集线器与交换机
 - 集线器：直联转发
 集线器工作在物理层，将接受信号放大发送到所有出口，本质上是搭建星形网，不进行碰撞检测

 - 交换机：存储转发
 交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发

 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。如果没有MAC地址信息，就广播

**** 局域网与以太网

 局域网是一种典型的广播信道，主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术。

 以太网有集线器以太网和交换机以太网

**** MAC地址
 一台主机拥有多少个网络适配器就有多少个 MAC 地址，6B（32bit）

 怎么根据IP地址确定mac地址并在交换机中寻找对应端口呢？

 目的mac地址：<<target-mac>>
 在实际的通信过程中，首先对目的IP地址进行判断，如果属于同一个网络（即IP地址前缀相同），就直接将其发送，而在这时就要使用物理地址，一般在计算机中都有一张IP地址到MAC地址的映射表。如果在表中有相应的IP地址到MAC地址的映射，则取出MAC地址，并将其填加在IP包的头部，然后将其转发出去，如果在表中没有响应的表项，则源站发出ARP广播，以获取对方的MAC地址，得到MAC地址后再将数据包发送出去。

 mac地址与端口：交换机来做

*** 网络层
 网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。
 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络

**** ICMP报文
 ICMP 报文分为差错报告报文和询问报文。
 - 差错报文：终点不可达， 时间超过， 参数问题， 改变路由
 - 询问报文：echo请求或回答， 时间戳请求或回答

**** ARP协议
 ARP 实现由 IP 地址得到 MAC 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

**** 路由器
 路由器从功能上可以划分为：路由选择和分组转发。
 - 分组转发
 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
 报告转发分组出错。

 - 路由选择协议划分为两大类：
 自治系统内部的路由选择：RIP 和 OSPF
 自治系统间的路由选择：BGP

**** RIP
 RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

 路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

 距离向量算法：

 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

 IP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

**** OSPF
 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的，使用了 Dijkstra 提出的最短路径算法 SPF。

 OSPF 具有以下特点：
 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
 只有当链路状态发生变化时，路由器才会发送信息。
 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

**** BGP
 AS 之间的路由选择很困难，主要是由于：
 互联网规模很大；
 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

 BGP 只能寻找一条比较好的路由，而不是最佳路由。

 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。
*** 传输层
**** TCP 与 UDP
 用户数据报协议 UDP（User Datagram Protocol）是 *无连接* 的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

 传输控制协议 TCP（Transmission Control Protocol）是 *面向连接* 的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接 *只能是点对点* 的（一对一）。

**** TCP 的三次握手

 假设 A 为客户端，B 为服务器端。

 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。
 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
 B 收到 A 的确认后，连接建立。

 三次握手的原因

 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接

**** TCP 的四次挥手

 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

 A 发送连接释放报文段，FIN=1；
 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据；
 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1；
 A 收到后发出确认，此时连接释放。

 四次挥手的原因

 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文

**** 可靠传输

 TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

***** 滑动窗口

 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节 *已经发送* 并且收到了 *确认* ，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节 *已经发送* 确认并 *交付主机* ，就向右滑动接收窗口。

 接收窗口只会对窗口内最后一个 *按序到达* 的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。


***** TCP 流量控制

 流量控制是为了控制 *发送方发送速率* ，保证接收方来得及接收。

 接收方发送的确认报文中的窗口字段可以用来 *控制发送方窗口大小* ，从而影响发送方的发送速率。例如将窗口字段设置为 0，则发送方不能发送数据。

***** TCP 拥塞控制

 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。

 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护有一个叫做拥塞窗口（cwnd）的状态变量。
 注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个 *状态变量* ，实际决定发送方能发送多少数据的是发送方窗口。

 - 慢开始与拥塞避免

 发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd *加倍* ，因此之后发送方能够发送的报文段为：2、4、8 ...

 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入 *拥塞避免* ，每个轮次只将 cwnd 加 1。

 如果出现了超时，则令 ssthresh = cwnd / 2，然后 *重新执行慢开始* 。

 - 快重传与快恢复

 在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

 在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。

 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。
* Basic
** DONE C++ string                                                     :NOTE:
   CLOSED: [2020-03-28 Sat 20:40]
   :PROPERTIES:
   :ID:       60694708-4932-4F29-AF30-E839E71A61A0
   :END:
   :LOGBOOK:
   CLOCK: [2020-03-06 Fri 09:27]--[2020-03-06 Fri 09:28] =>  0:01
   :END:
 [2020-03-06 Fri 09:27]

*** special usage
**** string s = string(10, 'c');  // 拷贝初始化

     string不接变量名，也是合法的。临时变量

**** for in const string
     :LOGBOOK:
     CLOCK: [2020-03-06 Fri 10:49]--[2020-03-06 Fri 11:03] =>  0:14
     :END:
 #+begin_src C++ :includes <iostream> <string> <cctype> :namespaces std
   int main(){
       // const string str_const = "Hello World";
       string str_const = "Hello World";
       for(auto & c : str_const)
           c = toupper(c);

       cout << str_const;

       return 0;
   }
 #+end_src

 #+RESULTS:
 : HELLO WORLD

  *ps:* cannot change const string
** think about string
   :LOGBOOK:
   CLOCK: [2020-03-03 Tue 10:40]--[2020-03-03 Tue 10:45] =>  0:05
   :END:
 [2020-03-03 Tue 10:40]

*** what is the memory usage?

    is the subfunction memory allocated when running? or when compiling?
      
    the total memory equals to the sum of all functions? or the sum of the main and the max subfunction memories?

*** what is the difference between string and char[]?

    what is the time consumption of string method such as insert()?

*** how to increase char[] length like vector<char>?
** DONE thinking about recursive
   CLOSED: [2020-07-02 Thu 18:49]
   :PROPERTIES:
   :ID:       B3B9ACA2-3E58-4986-829D-75226C2D3BF5
   :END:
   :LOGBOOK:
   CLOCK: [2020-03-03 Tue 11:01]--[2020-03-03 Tue 11:03] =>  0:02
   :END:
 [2020-03-03 Tue 11:01]

*** essentially a stack
*** binary recursive
